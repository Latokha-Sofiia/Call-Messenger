var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// projects/moq/src/public_api.ts
var public_api_exports = {};
__export(public_api_exports, {
  APPLY_RETURN_VALUE: () => APPLY_RETURN_VALUE,
  ApplyReflectorTrap: () => ApplyReflectorTrap,
  ApplyTrap: () => ApplyTrap,
  ArgumentsEqualityComparer: () => ArgumentsEqualityComparer,
  AsyncExpressionDetector: () => AsyncExpressionDetector,
  AsyncExpressionReflector: () => AsyncExpressionReflector,
  AsyncReflectingProxyInjectorFactory: () => AsyncReflectingProxyInjectorFactory,
  AutoMockFactory: () => AutoMockFactory,
  AutoMockInjectorConfig: () => AutoMockInjectorConfig,
  AutoMockNameFormatter: () => AutoMockNameFormatter,
  AutoMockOptionsBuilder: () => AutoMockOptionsBuilder,
  AutoMockProvider: () => AutoMockProvider,
  AutoMockedStorage: () => AutoMockedStorage,
  CONSTRUCT_RETURN_VALUE: () => CONSTRUCT_RETURN_VALUE,
  CallCounter: () => CallCounter,
  CallbackPresetFactory: () => CallbackPresetFactory,
  CallbackPresetPlayer: () => CallbackPresetPlayer,
  CallbacksPreset: () => CallbacksPreset,
  CommonTypeProvider: () => CommonTypeProvider,
  ComplexExpressionErrorFormatter: () => ComplexExpressionErrorFormatter,
  ComplexExpressionGuard: () => ComplexExpressionGuard,
  ComplexExpressionValidator: () => ComplexExpressionValidator,
  CompositeExpressionReflector: () => CompositeExpressionReflector,
  ConstantEqualityComparer: () => ConstantEqualityComparer,
  ConstantFormatter: () => ConstantFormatter,
  ConstructReflectorTrap: () => ConstructReflectorTrap,
  ConstructTrap: () => ConstructTrap,
  DateMatcher: () => DateMatcher,
  DefaultInjectorConfig: () => DefaultInjectorConfig,
  EXPRESSIONS: () => EXPRESSIONS,
  EXPRESSION_REFLECTOR: () => EXPRESSION_REFLECTOR,
  EqualConstantMatcher: () => EqualConstantMatcher,
  EqualMatcher: () => EqualMatcher,
  EqualMatchingInjectorConfig: () => EqualMatchingInjectorConfig,
  Expression: () => Expression,
  ExpressionEqualityComparer: () => ExpressionEqualityComparer,
  ExpressionFormatter: () => ExpressionFormatter,
  ExpressionGuardExceptionFactory: () => ExpressionGuardExceptionFactory,
  ExpressionHasMethodExplorer: () => ExpressionHasMethodExplorer,
  ExpressionHasPropertyExplorer: () => ExpressionHasPropertyExplorer,
  ExpressionValidator: () => ExpressionValidator,
  ExpressionsFormatter: () => ExpressionsFormatter,
  FunctionExpression: () => FunctionExpression,
  FunctionExpressionValidator: () => FunctionExpressionValidator,
  FunctionFormatter: () => FunctionFormatter,
  FunctionMatcher: () => FunctionMatcher,
  GET_RETURN_VALUE: () => GET_RETURN_VALUE,
  GetPropertyEqualityComparer: () => GetPropertyEqualityComparer,
  GetPropertyExpression: () => GetPropertyExpression,
  GetPropertyExpressionValidator: () => GetPropertyExpressionValidator,
  GetPropertyFormatter: () => GetPropertyFormatter,
  GetPrototypeOfTrap: () => GetPrototypeOfTrap,
  GetReflectorTrap: () => GetReflectorTrap,
  GetTrap: () => GetTrap,
  HasMethodExplorer: () => HasMethodExplorer,
  HasPropertyExplorer: () => HasPropertyExplorer,
  HasReflectorTrap: () => HasReflectorTrap,
  HasTrap: () => HasTrap,
  Host: () => Host,
  INJECTOR: () => INJECTOR,
  INJECTOR_IMPL: () => INJECTOR_IMPL,
  InOperatorEqualityComparer: () => InOperatorEqualityComparer,
  InOperatorExpression: () => InOperatorExpression,
  InOperatorExpressionValidator: () => InOperatorExpressionValidator,
  InOperatorFormatter: () => InOperatorFormatter,
  InOperatorInteractionExplorer: () => InOperatorInteractionExplorer,
  InjectFlags: () => InjectFlags,
  InjectionToken: () => InjectionToken,
  Injector: () => Injector,
  InstanceMethodEqualityComparer: () => InstanceMethodEqualityComparer,
  InstanceMethodExpressionValidator: () => InstanceMethodExpressionValidator,
  InteractionFormatter: () => InteractionFormatter,
  InteractionPlayer: () => InteractionPlayer,
  It: () => It,
  ItEqualityComparer: () => ItEqualityComparer,
  IterableTester: () => IterableTester,
  IteratorMatcher: () => IteratorMatcher,
  MOCK: () => MOCK,
  MOCK_CONSTRUCTOR: () => MOCK_CONSTRUCTOR,
  MOCK_OPTIONS: () => MOCK_OPTIONS,
  MapMatcher: () => MapMatcher,
  MembersMethodExplorer: () => MembersMethodExplorer,
  MembersPropertyExplorer: () => MembersPropertyExplorer,
  MethodEqualityComparer: () => MethodEqualityComparer,
  MethodExpression: () => MethodExpression,
  MethodFormatter: () => MethodFormatter,
  MethodOnlyReflectingProxyFactory: () => MethodOnlyReflectingProxyFactory,
  MethodReflectingProxyFactory: () => MethodReflectingProxyFactory,
  MethodReflectorTrap: () => MethodReflectorTrap,
  MimicsPreset: () => MimicsPreset,
  MimicsPresetFactory: () => MimicsPresetFactory,
  MimicsPresetPlayer: () => MimicsPresetPlayer,
  MimicsRejectedAsyncPresetFactory: () => MimicsRejectedAsyncPresetFactory,
  MimicsResolvedAsyncPresetFactory: () => MimicsResolvedAsyncPresetFactory,
  Mock: () => Mock,
  MockCore: () => MockCore,
  MockOptionsBuilder: () => MockOptionsBuilder,
  MoqAPI: () => MoqAPI,
  NG_TEMP_TOKEN_PATH: () => NG_TEMP_TOKEN_PATH,
  NO_NEW_LINE: () => NO_NEW_LINE,
  NamePrefixProvider: () => NamePrefixProvider,
  NewOperatorEqualityComparer: () => NewOperatorEqualityComparer,
  NewOperatorExpression: () => NewOperatorExpression,
  NewOperatorExpressionValidator: () => NewOperatorExpressionValidator,
  NewOperatorFormatter: () => NewOperatorFormatter,
  NullInjector: () => NullInjector,
  OBJECT_MATCHERS: () => OBJECT_MATCHERS,
  ObjectHasMethodExplorer: () => ObjectHasMethodExplorer,
  ObjectHasPropertyExplorer: () => ObjectHasPropertyExplorer,
  ObjectMapProvider: () => ObjectMapProvider,
  ObjectMatcher: () => ObjectMatcher,
  Optional: () => Optional,
  POJOMatcher: () => POJOMatcher,
  PlayTimes: () => PlayTimes,
  PlayableAlways: () => PlayableAlways,
  PlayableExactly: () => PlayableExactly,
  PlayableNever: () => PlayableNever,
  PlayableOnce: () => PlayableOnce,
  PlayablePresetProvider: () => PlayablePresetProvider,
  PlayableSequence: () => PlayableSequence,
  PlayableUpdateReason: () => PlayableUpdateReason,
  PresetBuilder: () => PresetBuilder,
  PresetBuilderFactory: () => PresetBuilderFactory,
  PresetHasInOperatorExplorer: () => PresetHasInOperatorExplorer,
  PresetHasMethodExplorer: () => PresetHasMethodExplorer,
  PresetHasPropertyExplorer: () => PresetHasPropertyExplorer,
  PresetPlayablesUpdater: () => PresetPlayablesUpdater,
  PresetPlayer: () => PresetPlayer,
  Presets: () => Presets,
  PrimitiveMatcher: () => PrimitiveMatcher,
  PropertiesValueStorage: () => PropertiesValueStorage,
  PropertyDescriptorProvider: () => PropertyDescriptorProvider,
  PropertyIsReadOnlyTester: () => PropertyIsReadOnlyTester,
  PropertyKeyFormatter: () => PropertyKeyFormatter,
  PrototypeStorage: () => PrototypeStorage,
  ProxyFactory: () => ProxyFactory,
  REFLECT_APPLY: () => REFLECT_APPLY,
  REFLECT_HAS: () => REFLECT_HAS,
  ROOT_MOCK: () => ROOT_MOCK,
  Range: () => Range,
  ReflectingProxyFactory: () => ReflectingProxyFactory,
  ReflectingProxyInjectorFactory: () => ReflectingProxyInjectorFactory,
  RejectedPromiseFactory: () => RejectedPromiseFactory,
  ResolvedPromiseFactory: () => ResolvedPromiseFactory,
  ReturnsAsyncPresetFactory: () => ReturnsAsyncPresetFactory,
  ReturnsPreset: () => ReturnsPreset,
  ReturnsPresetFactory: () => ReturnsPresetFactory,
  RootMockProvider: () => RootMockProvider,
  SOURCE: () => SOURCE,
  Self: () => Self,
  SequenceId: () => SequenceId,
  SetPropertyEqualityComparer: () => SetPropertyEqualityComparer,
  SetPropertyExpression: () => SetPropertyExpression,
  SetPropertyExpressionValidator: () => SetPropertyExpressionValidator,
  SetPropertyFormatter: () => SetPropertyFormatter,
  SetPrototypeOfTrap: () => SetPrototypeOfTrap,
  SetReflectorTrap: () => SetReflectorTrap,
  SetTrap: () => SetTrap,
  SetupFactory: () => SetupFactory,
  SkipSelf: () => SkipSelf,
  SpyFunctionProvider: () => SpyFunctionProvider,
  StaticInjector: () => StaticInjector,
  StringErrorStyler: () => StringErrorStyler,
  SyncExpressionReflector: () => SyncExpressionReflector,
  THROW_IF_NOT_FOUND: () => THROW_IF_NOT_FOUND,
  ThrowsAsyncPresetFactory: () => ThrowsAsyncPresetFactory,
  ThrowsPreset: () => ThrowsPreset,
  ThrowsPresetFactory: () => ThrowsPresetFactory,
  Times: () => Times,
  TrackedExpressionsFormatter: () => TrackedExpressionsFormatter,
  Tracker: () => Tracker,
  Type: () => Type,
  TypesMatcher: () => TypesMatcher,
  USE_VALUE: () => USE_VALUE,
  VerificationTester: () => VerificationTester,
  Verifier: () => Verifier,
  VerifyError: () => VerifyError,
  VerifyFormatter: () => VerifyFormatter,
  catchInjectorError: () => catchInjectorError,
  dump: () => dump,
  formatError: () => formatError,
  forwardRef: () => forwardRef,
  getClosureSafeProperty: () => getClosureSafeProperty,
  injectorFactory: () => injectorFactory,
  isForwardRef: () => isForwardRef,
  mockOptionsProviders: () => mockOptionsProviders,
  resolveForwardRef: () => resolveForwardRef,
  stringify: () => stringify
});
module.exports = __toCommonJS(public_api_exports);

// projects/moq/src/lib/formatters/tracked-expressions.formatter.ts
var TrackedExpressionsFormatter = class {
  constructor(interactionFormatter) {
    this.interactionFormatter = interactionFormatter;
  }
  format(trackedExpressions) {
    let result = "";
    for (const expression of trackedExpressions) {
      result += `${this.interactionFormatter.format(expression)}
`;
    }
    return result.substr(0, result.length - 1);
  }
};

// projects/moq/src/lib/dump.ts
function dump(mock, writer = console) {
  const formatter = mock.resolve(TrackedExpressionsFormatter);
  const expressions = mock.tracker.get().map((record) => record.expression);
  const output = formatter.format(expressions);
  const delimiter = "-------------------------------";
  writer.log(`Dump of ${mock.name === void 0 ? "noname mock" : mock.name}`);
  writer.log(delimiter);
  writer.log(`
${output}`);
  writer.log(delimiter);
}

// projects/moq/src/lib/times.ts
var Range = /* @__PURE__ */ ((Range2) => {
  Range2[Range2["Exclusive"] = 0] = "Exclusive";
  Range2[Range2["Inclusive"] = 1] = "Inclusive";
  return Range2;
})(Range || {});
var _Times = class {
  /**
   *
   * @param evaluator It takes actual value and decides if it is expected or not.
   * Returns true or false accordingly.
   * @param message A message that describes the expectation.
   */
  constructor(evaluator, message) {
    this.evaluator = evaluator;
    this.message = message;
  }
  /**
   * It expects that the actual would be equal or bigger then the expected value.
   *
   * @param callCount The expected value.
   */
  static AtLeast(callCount) {
    return new _Times((expected) => expected >= callCount, `Should be called at least ${callCount} time(s)`);
  }
  /**
   * It expects that the actual would be equal or bigger then 1.
   */
  static AtLeastOnce() {
    return _Times._atLeastOnce;
  }
  /**
   * It expects that the actual would be equal or smaller then the expected value.
   *
   * @param callCount The expected value.
   */
  static AtMost(callCount) {
    return new _Times((expected) => expected <= callCount, `Should be called at most ${callCount} time(s)`);
  }
  /**
   * It expects that the actual would be equal or less then 1.
   */
  static AtMostOnce() {
    return _Times._atMostOnce;
  }
  /**
   * It expects that the actual would be in the expected range of values.
   *
   * @param callCountFrom The lowest bound of the range.
   * @param callCountTo The highest bound of the range.
   * @param range  Sets the rules where bounds of a range are included or excluded from the range.
   */
  static Between(callCountFrom, callCountTo, range) {
    if (range === 0 /* Exclusive */) {
      return new _Times(
        (expected) => expected > callCountFrom && expected < callCountTo,
        `Should be called exclusively between ${callCountFrom} and ${callCountTo}`
      );
    }
    return new _Times(
      (expected) => expected >= callCountFrom && expected <= callCountTo,
      `Should be called inclusively between ${callCountFrom} and ${callCountTo}`
    );
  }
  /**
   * It expects that the actual is equal to the expected value.
   *
   * @param callCount The expected value.
   */
  static Exactly(callCount) {
    return new _Times(
      (expected) => expected === callCount,
      `Should be called exactly ${callCount} time(s)`
    );
  }
  /**
   * It expects that the actual is equal 0.
   */
  static Never() {
    return _Times._never;
  }
  /**
   * It expects that the actual is equal 1.
   */
  static Once() {
    return _Times._once;
  }
  /**
   * Evaluates the expectation against the actual value.
   *
   * @param callCount The actual value.
   */
  test(callCount) {
    return this.evaluator(callCount);
  }
};
var Times = _Times;
__publicField(Times, "_once", new _Times((expected) => expected === 1, "Should be called once"));
__publicField(Times, "_never", new _Times((expected) => expected === 0, "Should be called never"));
__publicField(Times, "_atMostOnce", new _Times((expected) => expected <= 1, "Should be called at most once"));
__publicField(Times, "_atLeastOnce", new _Times((expected) => expected >= 1, "Should be called at least once"));

// projects/moq/src/lib/static.injector/stringify.ts
function stringify(token) {
  if (typeof token === "string") {
    return token;
  }
  if (Array.isArray(token)) {
    return `[${token.map(stringify).join(", ")}]`;
  }
  if (token == null) {
    return `${token}`;
  }
  if (token.overriddenName) {
    return `${token.overriddenName}`;
  }
  if (token.name) {
    return `${token.name}`;
  }
  const res = token.toString();
  if (res == null) {
    return `${res}`;
  }
  const newLineIndex = res.indexOf("\n");
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

// projects/moq/src/lib/static.injector/property.ts
function getClosureSafeProperty(objWithPropertyToExtract) {
  for (const key in objWithPropertyToExtract) {
    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
      return key;
    }
  }
  throw Error("Could not find renamed property on target object.");
}

// projects/moq/src/lib/static.injector/forward_ref.ts
var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
function forwardRef(forwardRefFn) {
  forwardRefFn.__forward_ref__ = forwardRef;
  forwardRefFn.toString = function() {
    return stringify(this());
  };
  return forwardRefFn;
}
function resolveForwardRef(type) {
  return isForwardRef(type) ? type() : type;
}
function isForwardRef(fn) {
  return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;
}

// projects/moq/src/lib/static.injector/injection_token.ts
var InjectionToken = class {
  constructor(desc) {
    this.desc = desc;
  }
  toString() {
    return `InjectionToken ${this.desc}`;
  }
};

// projects/moq/src/lib/static.injector/injector_compatibility.ts
var INJECTOR = new InjectionToken(
  "INJECTOR"
);
var _THROW_IF_NOT_FOUND = {};
var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
var NG_TOKEN_PATH = "ngTokenPath";
var NEW_LINE = /\n/gm;
var NO_NEW_LINE = "\u0275";
var SOURCE = "__source";
var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
var NullInjector = class {
  get(token, notFoundValue = THROW_IF_NOT_FOUND) {
    if (notFoundValue === THROW_IF_NOT_FOUND) {
      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
      error.name = "NullInjectorError";
      throw error;
    }
    return notFoundValue;
  }
};
function catchInjectorError(e, token, injectorErrorName, source) {
  const tokenPath = e[NG_TEMP_TOKEN_PATH];
  if (token[SOURCE]) {
    tokenPath.unshift(token[SOURCE]);
  }
  e.message = formatError(`
${e.message}`, tokenPath, injectorErrorName, source);
  e[NG_TOKEN_PATH] = tokenPath;
  e[NG_TEMP_TOKEN_PATH] = null;
  throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
  text = text && text.charAt(0) === "\n" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;
  let context = stringify(obj);
  if (Array.isArray(obj)) {
    context = obj.map(stringify).join(" -> ");
  } else if (typeof obj === "object") {
    const parts = [];
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = obj[key];
        parts.push(
          `${key}:${typeof value === "string" ? JSON.stringify(value) : stringify(value)}`
        );
      }
    }
    context = `{${parts.join(", ")}}`;
  }
  return `${injectorErrorName}${source ? `(${source})` : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
}

// projects/moq/src/lib/static.injector/interface/injector.ts
var InjectFlags = /* @__PURE__ */ ((InjectFlags2) => {
  InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
  InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
  InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
  InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
  InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
  return InjectFlags2;
})(InjectFlags || {});

// projects/moq/src/lib/static.injector/metadata.ts
var Optional = class {
};
var Self = class {
};
var SkipSelf = class {
};
var Host = class {
};

// projects/moq/src/lib/static.injector/injector.ts
var INJECTOR_IMPL = (providers, parent, name) => new StaticInjector(providers, parent, name);
var Injector = class {
  static create(options, parent) {
    if (Array.isArray(options)) {
      return INJECTOR_IMPL(options, parent, "");
    } else {
      return INJECTOR_IMPL(options.providers, options.parent, options.name || "");
    }
  }
};
__publicField(Injector, "THROW_IF_NOT_FOUND", THROW_IF_NOT_FOUND);
__publicField(Injector, "NULL", new NullInjector());
/**
 * @internal
 * @nocollapse
 */
__publicField(Injector, "__NG_ELEMENT_ID__", -1);
var IDENT = function(value) {
  return value;
};
var EMPTY = [];
var CIRCULAR = IDENT;
var MULTI_PROVIDER_FN = function() {
  return Array.prototype.slice.call(arguments);
};
var StaticInjector = class {
  parent;
  source;
  scope;
  _records;
  constructor(providers, parent = new NullInjector(), source = null) {
    this.parent = parent;
    this.source = source;
    const records = this._records = /* @__PURE__ */ new Map();
    records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
    records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
    this.scope = recursivelyProcessProviders(records, providers);
  }
  get(token, notFoundValue, flags = 0 /* Default */) {
    const records = this._records;
    const record = records.get(token);
    if (record === void 0) {
      records.set(token, null);
    }
    try {
      return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
    } catch (e) {
      return catchInjectorError(e, token, "StaticInjectorError", this.source);
    }
  }
  toString() {
    const tokens = [];
    const records = this._records;
    records.forEach((v, token) => tokens.push(stringify(token)));
    return `StaticInjector[${tokens.join(", ")}]`;
  }
};
function resolveProvider(provider) {
  const deps = computeDeps(provider);
  let fn = IDENT;
  let value = EMPTY;
  let useNew = false;
  const provide = resolveForwardRef(provider.provide);
  if (USE_VALUE in provider) {
    value = provider.useValue;
  } else if (provider.useFactory) {
    fn = provider.useFactory;
  } else if (provider.useExisting) {
  } else if (provider.useClass) {
    useNew = true;
    fn = resolveForwardRef(provider.useClass);
  } else if (typeof provide === "function") {
    useNew = true;
    fn = provide;
  } else {
    throw staticError(
      "StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable",
      provider
    );
  }
  return { deps, fn, useNew, value };
}
function multiProviderMixError(token) {
  return staticError("Cannot mix multi providers and regular providers", token);
}
function recursivelyProcessProviders(records, provider) {
  let scope = null;
  if (provider) {
    provider = resolveForwardRef(provider);
    if (Array.isArray(provider)) {
      for (let i = 0; i < provider.length; i++) {
        scope = recursivelyProcessProviders(records, provider[i]) || scope;
      }
    } else if (typeof provider === "function") {
      throw staticError("Function/Class not supported", provider);
    } else if (provider && typeof provider === "object" && provider.provide) {
      let token = resolveForwardRef(provider.provide);
      const resolvedProvider = resolveProvider(provider);
      if (provider.multi === true) {
        let multiProvider = records.get(token);
        if (multiProvider) {
          if (multiProvider.fn !== MULTI_PROVIDER_FN) {
            throw multiProviderMixError(token);
          }
        } else {
          records.set(token, multiProvider = {
            token: provider.provide,
            deps: [],
            useNew: false,
            fn: MULTI_PROVIDER_FN,
            value: EMPTY
          });
        }
        token = provider;
        multiProvider.deps.push({ token, options: 6 /* Default */ });
      }
      const record = records.get(token);
      if (record && record.fn === MULTI_PROVIDER_FN) {
        throw multiProviderMixError(token);
      }
      records.set(token, resolvedProvider);
    } else {
      throw staticError("Unexpected provider", provider);
    }
  }
  return scope;
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
  try {
    return resolveToken(token, record, records, parent, notFoundValue, flags);
  } catch (e) {
    if (!(e instanceof Error)) {
      e = new Error(e);
    }
    const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
    path.unshift(token);
    if (record && record.value === CIRCULAR) {
      record.value = EMPTY;
    }
    throw e;
  }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
  let value;
  if (record && !(flags & 4 /* SkipSelf */)) {
    value = record.value;
    if (value === CIRCULAR) {
      throw Error(`${NO_NEW_LINE}Circular dependency`);
    } else if (value === EMPTY) {
      record.value = CIRCULAR;
      const { useNew, fn, deps: depRecords } = record;
      let deps = EMPTY;
      if (depRecords.length) {
        deps = [];
        for (let i = 0; i < depRecords.length; i++) {
          const depRecord = depRecords[i];
          const options = depRecord.options;
          const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : void 0;
          deps.push(tryResolveToken(
            // Current Token to resolve
            depRecord.token,
            // A record which describes how to resolve the token.
            // If undefined, this means we don't have such a record
            childRecord,
            // Other records we know about.
            records,
            // If we don't know how to resolve dependency and we should not check parent for it,
            // than pass in Null injector.
            // eslint-disable-next-line no-bitwise
            !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent,
            // eslint-disable-next-line no-bitwise
            options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND,
            0 /* Default */
          ));
        }
      }
      record.value = value = useNew ? new fn(...deps) : fn.apply(void 0, deps);
    }
  } else if (!(flags & 2 /* Self */)) {
    value = parent.get(token, notFoundValue, 0 /* Default */);
  } else if (!(flags & 8 /* Optional */)) {
    value = Injector.NULL.get(token, notFoundValue);
  } else {
    value = Injector.NULL.get(token, typeof notFoundValue !== "undefined" ? notFoundValue : null);
  }
  return value;
}
function computeDeps(provider) {
  let deps = EMPTY;
  const providerDeps = provider.deps;
  if (providerDeps && providerDeps.length) {
    deps = [];
    for (let i = 0; i < providerDeps.length; i++) {
      let options = 6 /* Default */;
      let token = resolveForwardRef(providerDeps[i]);
      if (Array.isArray(token)) {
        for (let j = 0, annotations = token; j < annotations.length; j++) {
          const annotation = annotations[j];
          if (annotation instanceof Optional || annotation === Optional) {
            options = options | 1 /* Optional */;
          } else if (annotation instanceof SkipSelf || annotation === SkipSelf) {
            options = options & ~2 /* CheckSelf */;
          } else if (annotation instanceof Self || annotation === Self) {
            options = options & ~4 /* CheckParent */;
          } else {
            token = resolveForwardRef(annotation);
          }
        }
      }
      deps.push({ token, options });
    }
  } else if (provider.useExisting) {
    const token = resolveForwardRef(provider.useExisting);
    deps = [{ token, options: 6 /* Default */ }];
  } else if (!providerDeps && !(USE_VALUE in provider)) {
    throw staticError("'deps' required", provider);
  }
  return deps;
}
function staticError(text, obj) {
  return new Error(formatError(text, obj, "StaticInjectorError"));
}

// projects/moq/src/lib/injector/injector.factory.ts
function injectorFactory(options, ...providers) {
  const { injectorConfig } = options;
  if (injectorConfig) {
    const resolved = injectorConfig.get(options, providers);
    return Injector.create({
      providers: resolved
    });
  }
  throw new Error("injectorConfig is not defined");
}

// projects/moq/src/lib/injector/mock.injection-token.ts
var MOCK = new InjectionToken("IMock");

// projects/moq/src/lib/tracker/sequence-id.ts
var SequenceId = class {
  value = 0;
  next() {
    return this.value++;
  }
};

// projects/moq/src/lib/tracker/tracker.ts
var Tracker = class {
  constructor(sequenceId) {
    this.sequenceId = sequenceId;
  }
  log = [];
  /**
   * @hidden
   */
  add(action) {
    const record = { id: this.sequenceId.next(), expression: action };
    this.log.push(record);
  }
  /**
   * Returns recorded interactions.
   */
  get() {
    return [...this.log];
  }
  interactions() {
    return this.get().map((record) => record.expression);
  }
};

// projects/moq/src/lib/tracker/index.ts
var tracker_default = [
  { provide: SequenceId, useClass: SequenceId, deps: [] },
  { provide: Tracker, useClass: Tracker, deps: [SequenceId] }
];

// projects/moq/src/lib/reflector/expression-reflector.ts
var EXPRESSION_REFLECTOR = new InjectionToken("Expression reflector");
var EXPRESSIONS = new InjectionToken("reflected expressions");
var GET_RETURN_VALUE = new InjectionToken("return value factory for the get trap");
var APPLY_RETURN_VALUE = new InjectionToken("return value factory for the apply trap");
var CONSTRUCT_RETURN_VALUE = new InjectionToken("return value factory for the construct trap");

// projects/moq/src/lib/reflector/expressions.ts
var Expression = class {
  constructor(name, args) {
    this.name = name;
    this.args = args;
  }
};
var MethodExpression = class extends Expression {
  constructor(name, args) {
    super(name, args);
  }
};
var FunctionExpression = class extends Expression {
  constructor(args) {
    super(void 0, args);
  }
};
var GetPropertyExpression = class extends Expression {
  constructor(name) {
    super(name, void 0);
  }
};
var SetPropertyExpression = class extends Expression {
  constructor(name, value) {
    super(name, [value]);
    this.value = value;
  }
};
var InOperatorExpression = class extends Expression {
  constructor(name) {
    super(name, void 0);
  }
};
var NewOperatorExpression = class extends Expression {
  constructor(args) {
    super(void 0, args);
  }
};

// projects/moq/src/lib/reflector/traps/get.reflector-trap.ts
var GetReflectorTrap = class {
  constructor(returnValueFactory, expressions) {
    this.returnValueFactory = returnValueFactory;
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, name) => {
      this.expressions.push(new GetPropertyExpression(name));
      return this.returnValueFactory.create();
    };
  }
};

// projects/moq/src/lib/reflector/traps/set.reflector-trap.ts
var SetReflectorTrap = class {
  constructor(expressions) {
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, name, value) => {
      this.expressions.push(new SetPropertyExpression(name, value));
      return true;
    };
  }
};

// projects/moq/src/lib/reflector/traps/apply.reflector-trap.ts
var ApplyReflectorTrap = class {
  constructor(returnValueFactory, expressions) {
    this.returnValueFactory = returnValueFactory;
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, thisArg, args) => {
      const last = this.expressions.pop();
      if (last instanceof GetPropertyExpression) {
        this.expressions.push(new MethodExpression(last.name, args));
      } else {
        if (last !== void 0) {
          this.expressions.push(last);
        }
        this.expressions.push(new FunctionExpression(args));
      }
      return this.returnValueFactory.create();
    };
  }
};

// projects/moq/src/lib/reflector/traps/has.reflector-trap.ts
var HasReflectorTrap = class {
  constructor(expressions) {
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, name) => {
      this.expressions.push(new InOperatorExpression(name));
      return true;
    };
  }
};

// projects/moq/src/lib/reflector/traps/construct.reflector-trap.ts
var ConstructReflectorTrap = class {
  constructor(returnValueFactory, expressions) {
    this.returnValueFactory = returnValueFactory;
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, args) => {
      this.expressions.push(new NewOperatorExpression(args));
      return this.returnValueFactory.create();
    };
  }
};

// projects/moq/src/lib/reflector/reflecting-proxy.factory.ts
var ReflectingProxyFactory = class {
  constructor(injector) {
    this.injector = injector;
  }
  create() {
    const get = this.injector.get(GetReflectorTrap);
    const set = this.injector.get(SetReflectorTrap);
    const apply = this.injector.get(ApplyReflectorTrap);
    const has = this.injector.get(HasReflectorTrap);
    const construct = this.injector.get(ConstructReflectorTrap);
    const options = { get, set, apply, has, construct };
    const reflector = function() {
      return void 0;
    };
    return new Proxy(reflector, options);
  }
};

// projects/moq/src/lib/reflector/reflecting-proxy.injector-factory.ts
var ReflectingProxyInjectorFactory = class {
  create(options = { providers: [] }) {
    const providers = [
      { provide: EXPRESSIONS, useValue: [], deps: [] },
      { provide: ReflectingProxyFactory, useClass: ReflectingProxyFactory, deps: [Injector] },
      { provide: GetReflectorTrap, useClass: GetReflectorTrap, deps: [GET_RETURN_VALUE, EXPRESSIONS] },
      { provide: GET_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
      { provide: SetReflectorTrap, useClass: SetReflectorTrap, deps: [EXPRESSIONS] },
      { provide: ApplyReflectorTrap, useClass: ApplyReflectorTrap, deps: [APPLY_RETURN_VALUE, EXPRESSIONS] },
      { provide: APPLY_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
      { provide: HasReflectorTrap, useClass: HasReflectorTrap, deps: [EXPRESSIONS] },
      {
        provide: ConstructReflectorTrap,
        useClass: ConstructReflectorTrap,
        deps: [CONSTRUCT_RETURN_VALUE, EXPRESSIONS]
      },
      { provide: CONSTRUCT_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
      ...options.providers
    ];
    return Injector.create({ providers });
  }
};

// projects/moq/src/lib/reflector/expression-predicates.ts
var _It = class {
  constructor(predicate) {
    this.predicate = predicate;
  }
  /**
   * This factory method returns an expression that matches custom cases.
   *
   * @example
   * ```typescript
   *
   *  const value = 'value';
   *  const object = new Mock<Function>()
   *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
   *  .returns(value)
   *  .object();
   *
   *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
   *
   *  expect(actual).toBe(value);
   * ```
   */
  static Is(predicate) {
    return new _It(predicate);
  }
  /**
   * This factory method returns a wildcat expression that matches any value.
   *
   * @example
   * ```typescript
   *
   *  const value = 'value';
   *  const object = new Mock<Function>()
   *  .setup(instance => instance(It.IsAny())
   *  .returns(value)
   *  .object();
   *
   *  const actual = object(any_value_will_trigger_the_setup);
   *
   *  expect(actual).toBe(value);
   * ```
   */
  static IsAny() {
    return new _It(_It.isAnyPredicate);
  }
  /**
   * Exams if the instance matches the predicate.
   */
  test(instance) {
    try {
      const result = this.predicate(instance);
      return result === true || result === void 0;
    } catch (e) {
      return false;
    }
  }
};
var It = _It;
__publicField(It, "isAnyPredicate", () => true);

// projects/moq/src/lib/reflector/sync-expression.reflector.ts
var SyncExpressionReflector = class {
  constructor(injectorFactory2) {
    this.injectorFactory = injectorFactory2;
  }
  /**
   * Reflects the provided code as an expression tree.
   */
  reflect(expression) {
    if (expression instanceof It) {
      return [expression];
    }
    const injector = this.injectorFactory.create();
    const proxyFactory = injector.get(ReflectingProxyFactory);
    const proxy = proxyFactory.create();
    const predicate = expression(proxy);
    const expressions = injector.get(EXPRESSIONS);
    return predicate instanceof It && expressions.length === 0 ? [predicate] : expressions;
  }
  async reflectAsync(expression) {
    if (expression instanceof It) {
      return [expression];
    }
    const injector = this.injectorFactory.create();
    const proxyFactory = injector.get(ReflectingProxyFactory);
    const proxy = proxyFactory.create();
    const predicate = await expression(proxy);
    const expressions = injector.get(EXPRESSIONS);
    return predicate instanceof It && expressions.length === 0 ? [predicate] : expressions;
  }
};

// projects/moq/src/lib/reflector/composite-expression.reflector.ts
var CompositeExpressionReflector = class {
  constructor(asyncExpressionDetector, syncExpressionReflector, asyncExpressionReflector) {
    this.asyncExpressionDetector = asyncExpressionDetector;
    this.syncExpressionReflector = syncExpressionReflector;
    this.asyncExpressionReflector = asyncExpressionReflector;
  }
  /**
   * Reflects the provided code as an expression tree.
   */
  reflect(expression) {
    return this.asyncExpressionDetector.isAsync(expression) ? this.asyncExpressionReflector.reflect(expression) : this.syncExpressionReflector.reflect(expression);
  }
};

// projects/moq/src/lib/reflector/async-expression.detector.ts
var AsyncExpressionDetector = class {
  isAsync(expression) {
    if (expression instanceof It) {
      return false;
    }
    const get = () => proxy;
    const set = () => true;
    const apply = () => proxy;
    const has = () => false;
    const construct = () => proxy;
    const options = { get, set, apply, has, construct };
    const reflector = function() {
      return void 0;
    };
    const proxy = new Proxy(reflector, options);
    const predicate = expression(proxy);
    return predicate instanceof It ? false : predicate instanceof Promise;
  }
};

// projects/moq/src/lib/reflector/async-expression.reflector.ts
var AsyncExpressionReflector = class {
  constructor(injectorFactory2) {
    this.injectorFactory = injectorFactory2;
  }
  /**
   * Reflects the provided async code as an expression tree.
   */
  reflect(expression) {
    const injector = this.injectorFactory.create();
    const proxyFactory = injector.get(ReflectingProxyFactory);
    const proxy = proxyFactory.create();
    expression(proxy);
    return injector.get(EXPRESSIONS);
  }
};

// projects/moq/src/lib/reflector/traps/method.reflector-trap.ts
var MethodReflectorTrap = class {
  constructor(expressions) {
    this.expressions = expressions;
    return this.factory();
  }
  factory() {
    return (target, thisArg, args) => {
      const last = this.expressions.pop();
      if (last instanceof GetPropertyExpression) {
        this.expressions.push(new MethodExpression(last.name, args));
      } else {
        if (last !== void 0) {
          this.expressions.push(last);
        }
      }
      return void 0;
    };
  }
};

// projects/moq/src/lib/reflector/method-only-reflecting-proxy.factory.ts
var MethodOnlyReflectingProxyFactory = class {
  constructor(injector) {
    this.injector = injector;
  }
  create() {
    const apply = this.injector.get(MethodReflectorTrap);
    const options = { apply };
    const reflector = function() {
      return void 0;
    };
    return new Proxy(reflector, options);
  }
};

// projects/moq/src/lib/reflector/async-reflecting-proxy.injector-factory.ts
var AsyncReflectingProxyInjectorFactory = class {
  constructor(reflectingProxyInjectorFactory) {
    this.reflectingProxyInjectorFactory = reflectingProxyInjectorFactory;
  }
  create(options = { providers: [] }) {
    const providers = [
      { provide: GET_RETURN_VALUE, useExisting: MethodOnlyReflectingProxyFactory, deps: [] },
      { provide: MethodOnlyReflectingProxyFactory, useClass: MethodOnlyReflectingProxyFactory, deps: [Injector] },
      { provide: APPLY_RETURN_VALUE, useValue: { create: () => ({}) }, deps: [] },
      { provide: CONSTRUCT_RETURN_VALUE, useValue: { create: () => ({}) }, deps: [] },
      { provide: MethodReflectorTrap, useClass: MethodReflectorTrap, deps: [EXPRESSIONS] },
      ...options.providers
    ];
    return this.reflectingProxyInjectorFactory.create({ providers });
  }
};

// projects/moq/src/lib/reflector/index.ts
var reflector_default = [
  { provide: EXPRESSION_REFLECTOR, useExisting: CompositeExpressionReflector, deps: [] },
  {
    provide: CompositeExpressionReflector,
    useClass: CompositeExpressionReflector,
    deps: [AsyncExpressionDetector, SyncExpressionReflector, AsyncExpressionReflector]
  },
  { provide: AsyncExpressionDetector, useClass: AsyncExpressionDetector, deps: [] },
  { provide: ReflectingProxyInjectorFactory, useClass: ReflectingProxyInjectorFactory, deps: [] },
  { provide: SyncExpressionReflector, useClass: SyncExpressionReflector, deps: [ReflectingProxyInjectorFactory] },
  {
    provide: AsyncReflectingProxyInjectorFactory,
    useClass: AsyncReflectingProxyInjectorFactory,
    deps: [ReflectingProxyInjectorFactory]
  },
  {
    provide: AsyncExpressionReflector,
    useClass: AsyncExpressionReflector,
    deps: [AsyncReflectingProxyInjectorFactory]
  }
];

// projects/moq/src/lib/presets/presets.ts
var Presets = class {
  presets = [];
  add(preset) {
    this.presets.unshift(preset);
  }
  get() {
    return [...this.presets];
  }
};

// projects/moq/src/lib/moq.ts
var PlayableUpdateReason = /* @__PURE__ */ ((PlayableUpdateReason2) => {
  PlayableUpdateReason2[PlayableUpdateReason2["OwnSetupWouldBePlayed"] = 0] = "OwnSetupWouldBePlayed";
  PlayableUpdateReason2[PlayableUpdateReason2["OtherSetupWouldBePlayed"] = 1] = "OtherSetupWouldBePlayed";
  return PlayableUpdateReason2;
})(PlayableUpdateReason || {});
var MoqAPI = Symbol("MoqAPI");

// projects/moq/src/lib/playables/playable-exactly.ts
var PlayableExactly = class {
  constructor(count) {
    this.count = count;
  }
  invoked = 0;
  update = (reason) => {
    if (reason === 0 /* OwnSetupWouldBePlayed */) {
      this.invoked++;
    }
  };
  isPlayable = () => this.invoked < this.count;
};

// projects/moq/src/lib/playables/playable-never.ts
var PlayableNever = class {
  update = () => void 0;
  isPlayable = () => false;
};

// projects/moq/src/lib/playables/playable-once.ts
var PlayableOnce = class {
  played = false;
  update = (reason) => {
    if (reason === 0 /* OwnSetupWouldBePlayed */) {
      this.played = true;
    }
  };
  isPlayable = () => this.played === false;
};

// projects/moq/src/lib/playables/playable-always.ts
var PlayableAlways = class {
  isPlayable = () => true;
  update = () => void 0;
};

// projects/moq/src/lib/playables/playable-sequence.ts
var PlayableSequence = class {
  constructor(sequence) {
    this.sequence = sequence;
  }
  index = 0;
  update = () => {
    this.index++;
  };
  isPlayable = () => {
    if (this.index >= this.sequence.length)
      return false;
    return this.sequence[this.index];
  };
};

// projects/moq/src/lib/playables/play-times.ts
var _PlayTimes = class {
  /**
   * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
   */
  static Exactly(count) {
    return new PlayableExactly(count);
  }
  /**
   * The configured setup will be always applied to invocations.
   */
  static Always() {
    return _PlayTimes.always;
  }
  /**
   * The configured setup will be never applied to invocations.
   */
  static Never() {
    return _PlayTimes.never;
  }
  /**
   * The configured setup will be applied only to the first invocation.
   */
  static Once() {
    return new PlayableOnce();
  }
  /**
   * The configured setup will be applied or not accordingly to the value in the sequence.
   *
   * @example
   * ```typescript
   *
   * const value = 'value';
   * const object = new Mock<Function>()
   * .setup(instance => instance(1))
   * .play(PlayTimes.Sequence([false, true]))
   * .returns(value)
   * .object();
   *
   * expect(object(1).toBe(undefined);
   * expect(object(1).toBe(value);
   * expect(object(1).toBe(undefined);
   * ```
   */
  static Sequence(sequence) {
    return new PlayableSequence(sequence);
  }
};
var PlayTimes = _PlayTimes;
__publicField(PlayTimes, "always", new PlayableAlways());
__publicField(PlayTimes, "never", new PlayableNever());

// projects/moq/src/lib/presets/preset-builder.ts
var PresetBuilder = class {
  constructor(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory, target, playable = PlayTimes.Always()) {
    this.returnsPresetFactory = returnsPresetFactory;
    this.throwsPresetFactory = throwsPresetFactory;
    this.mimicsPresetFactory = mimicsPresetFactory;
    this.callbackPresetFactory = callbackPresetFactory;
    this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
    this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
    this.target = target;
    this.playable = playable;
  }
  returnsAsync(value) {
    return this.returnsAsyncPresetFactory(this.target, this.playable, value);
  }
  throwsAsync(exception) {
    return this.throwsAsyncPresetFactory(this.target, this.playable, exception);
  }
  mimics(origin) {
    return this.mimicsPresetFactory(this.target, this.playable, origin);
  }
  returns(value) {
    return this.returnsPresetFactory(this.target, this.playable, value);
  }
  throws(exception) {
    return this.throwsPresetFactory(this.target, this.playable, exception);
  }
  callback(callback) {
    return this.callbackPresetFactory(this.target, this.playable, callback);
  }
  play(playable) {
    this.playable = playable;
    return this;
  }
};

// projects/moq/src/lib/presets/preset-builder.factory.ts
var PresetBuilderFactory = class {
  constructor(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory) {
    this.returnsPresetFactory = returnsPresetFactory;
    this.throwsPresetFactory = throwsPresetFactory;
    this.mimicsPresetFactory = mimicsPresetFactory;
    this.callbackPresetFactory = callbackPresetFactory;
    this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
    this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
    return this.factory();
  }
  factory() {
    return (target) => new PresetBuilder(
      this.returnsPresetFactory,
      this.throwsPresetFactory,
      this.mimicsPresetFactory,
      this.callbackPresetFactory,
      this.returnsAsyncPresetFactory,
      this.throwsAsyncPresetFactory,
      target
    );
  }
};

// projects/moq/src/lib/presets/setup.factory.ts
var SetupFactory = class {
  constructor(presetBuilderFactory, autoMockProvider, expressionGuard) {
    this.presetBuilderFactory = presetBuilderFactory;
    this.autoMockProvider = autoMockProvider;
    this.expressionGuard = expressionGuard;
  }
  create([shallow, ...rest]) {
    this.expressionGuard.verify([shallow, ...rest]);
    const preset = this.presetBuilderFactory(shallow);
    if (rest.length === 0) {
      return preset;
    }
    const mock = this.autoMockProvider.getOrCreate(shallow);
    preset.returns(mock.object());
    const setup = mock.resolve(SetupFactory);
    return setup.create(rest);
  }
};

// projects/moq/src/lib/auto-mocking/root-mock.provider.ts
var RootMockProvider = class {
  constructor(mock, root) {
    this.mock = mock;
    this.root = root;
    return this.factory();
  }
  factory() {
    return this.root ?? this.mock;
  }
};

// projects/moq/src/lib/auto-mocking/auto-mock.provider.ts
var AutoMockProvider = class {
  constructor(map, comparer, autoMockFactory) {
    this.map = map;
    this.comparer = comparer;
    this.autoMockFactory = autoMockFactory;
  }
  getOrCreate(expression) {
    for (const [key, value] of this.map) {
      if (this.comparer.equals(expression, key) === true) {
        return value;
      }
    }
    const mock = this.autoMockFactory.create(expression);
    this.map.set(expression, mock);
    return mock;
  }
};

// projects/moq/src/lib/presets/presets/callbacks.preset.ts
var CallbacksPreset = class {
  constructor(playable, target, callback) {
    this.playable = playable;
    this.target = target;
    this.callback = callback;
  }
};

// projects/moq/src/lib/presets/factories/callback-preset.factory.ts
var CallbackPresetFactory = class {
  constructor(rootMock, presets) {
    this.rootMock = rootMock;
    this.presets = presets;
    return this.factory();
  }
  factory() {
    return (target, playable, callback) => {
      const preset = new CallbacksPreset(playable, target, callback);
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/presets/mimics.preset.ts
var MimicsPreset = class {
  constructor(playable, target, origin) {
    this.playable = playable;
    this.target = target;
    this.origin = origin;
  }
};

// projects/moq/src/lib/presets/factories/mimics-preset.factory.ts
var MimicsPresetFactory = class {
  constructor(rootMock, presets) {
    this.rootMock = rootMock;
    this.presets = presets;
    return this.factory();
  }
  factory() {
    return (target, playable, origin) => {
      const preset = new MimicsPreset(playable, target, origin);
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/presets/returns.preset.ts
var ReturnsPreset = class {
  constructor(playable, target, value) {
    this.playable = playable;
    this.target = target;
    this.value = value;
  }
};

// projects/moq/src/lib/presets/factories/returns-async-preset.factory.ts
var ReturnsAsyncPresetFactory = class {
  constructor(rootMock, presets, resolvedPromise) {
    this.rootMock = rootMock;
    this.presets = presets;
    this.resolvedPromise = resolvedPromise;
    return this.factory();
  }
  factory() {
    return (target, playable, value) => {
      const preset = new ReturnsPreset(playable, target, this.resolvedPromise(value));
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/factories/returns-preset.factory.ts
var ReturnsPresetFactory = class {
  constructor(rootMock, presets) {
    this.rootMock = rootMock;
    this.presets = presets;
    return this.factory();
  }
  factory() {
    return (target, playable, value) => {
      const preset = new ReturnsPreset(playable, target, value);
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/factories/throws-async-preset.factory.ts
var ThrowsAsyncPresetFactory = class {
  constructor(rootMock, presets, rejectedPromise) {
    this.rootMock = rootMock;
    this.presets = presets;
    this.rejectedPromise = rejectedPromise;
    return this.factory();
  }
  factory() {
    return (target, playable, exception) => {
      const preset = new ReturnsPreset(playable, target, this.rejectedPromise(exception));
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/presets/throws.preset.ts
var ThrowsPreset = class {
  constructor(playable, target, exception) {
    this.playable = playable;
    this.target = target;
    this.exception = exception;
  }
};

// projects/moq/src/lib/presets/factories/throws-preset.factory.ts
var ThrowsPresetFactory = class {
  constructor(rootMock, presets) {
    this.rootMock = rootMock;
    this.presets = presets;
    return this.factory();
  }
  factory() {
    return (target, playable, exception) => {
      const preset = new ThrowsPreset(playable, target, exception);
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/resolved-promise.factory.ts
var ResolvedPromiseFactory = class {
  constructor() {
    return this.factory();
  }
  factory() {
    return (value) => {
      const promise = Promise.resolve(value);
      promise.then = promise.then.bind(promise);
      promise.catch = promise.catch.bind(promise);
      promise.finally = promise.finally.bind(promise);
      return promise;
    };
  }
};

// projects/moq/src/lib/presets/rejected-promise.factory.ts
var RejectedPromiseFactory = class {
  constructor() {
    return this.factory();
  }
  factory() {
    return (value) => {
      const promise = Promise.reject(value);
      promise.then = promise.then.bind(promise);
      promise.catch = promise.catch.bind(promise);
      promise.finally = promise.finally.bind(promise);
      return promise;
    };
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/complex-expression.guard.ts
var ComplexExpressionGuard = class {
  constructor(complexExpressionValidator, expressionGuardExceptionFactory) {
    this.complexExpressionValidator = complexExpressionValidator;
    this.expressionGuardExceptionFactory = expressionGuardExceptionFactory;
  }
  verify(expressions) {
    const { valid, errors } = this.complexExpressionValidator.validate(expressions);
    if (valid === false) {
      throw this.expressionGuardExceptionFactory.create(errors);
    }
  }
};

// projects/moq/src/lib/presets/index.ts
var presets_default = [
  {
    provide: SetupFactory,
    useClass: SetupFactory,
    deps: [PresetBuilderFactory, AutoMockProvider, ComplexExpressionGuard]
  },
  { provide: Presets, useClass: Presets, deps: [] },
  { provide: ResolvedPromiseFactory, useClass: ResolvedPromiseFactory, deps: [] },
  { provide: RejectedPromiseFactory, useClass: RejectedPromiseFactory, deps: [] },
  { provide: ReturnsPresetFactory, useClass: ReturnsPresetFactory, deps: [RootMockProvider, Presets] },
  { provide: ThrowsPresetFactory, useClass: ThrowsPresetFactory, deps: [RootMockProvider, Presets] },
  { provide: CallbackPresetFactory, useClass: CallbackPresetFactory, deps: [RootMockProvider, Presets] },
  { provide: MimicsPresetFactory, useClass: MimicsPresetFactory, deps: [RootMockProvider, Presets] },
  {
    provide: ReturnsAsyncPresetFactory,
    useClass: ReturnsAsyncPresetFactory,
    deps: [RootMockProvider, Presets, ResolvedPromiseFactory]
  },
  {
    provide: ThrowsAsyncPresetFactory,
    useClass: ThrowsAsyncPresetFactory,
    deps: [RootMockProvider, Presets, RejectedPromiseFactory]
  },
  {
    provide: PresetBuilderFactory,
    useClass: PresetBuilderFactory,
    deps: [
      ReturnsPresetFactory,
      ThrowsPresetFactory,
      MimicsPresetFactory,
      CallbackPresetFactory,
      ReturnsAsyncPresetFactory,
      ThrowsAsyncPresetFactory
    ]
  }
];

// projects/moq/src/lib/verification/verifier.ts
var Verifier = class {
  constructor(callCounter, verificationTester, autoMockProvider) {
    this.callCounter = callCounter;
    this.verificationTester = verificationTester;
    this.autoMockProvider = autoMockProvider;
  }
  test([shallow, ...rest], times) {
    const callCount = this.callCounter.count(shallow);
    if (rest.length === 0) {
      this.verificationTester.test(shallow, callCount, times);
    } else {
      this.verificationTester.test(shallow, callCount, Times.AtLeastOnce());
      const autoMock = this.autoMockProvider.getOrCreate(shallow);
      const verifier = autoMock.resolve(Verifier);
      verifier.test(rest, times);
    }
  }
};

// projects/moq/src/lib/verification/call-counter.ts
var CallCounter = class {
  constructor(comparer, tracker) {
    this.comparer = comparer;
    this.tracker = tracker;
  }
  count(expected) {
    let count = 0;
    for (const expression of this.tracker.interactions()) {
      if (this.comparer.equals(expression, expected) === true) {
        count += 1;
      }
    }
    return count;
  }
};

// projects/moq/src/lib/formatters/verify.formatter.ts
var VerifyFormatter = class {
  constructor(expressionsFormatter, trackedExpressionsFormatter, tracker) {
    this.expressionsFormatter = expressionsFormatter;
    this.trackedExpressionsFormatter = trackedExpressionsFormatter;
    this.tracker = tracker;
  }
  format(expected, timesMessage, haveBeenCalledTimes) {
    const interactions = this.tracker.interactions();
    const expectedExpressionMessage = this.expressionsFormatter.format(expected, timesMessage, haveBeenCalledTimes);
    const trackedExpressionsMessage = this.trackedExpressionsFormatter.format(interactions);
    const delimiter = "-------------------------------------";
    return `${expectedExpressionMessage}
${delimiter}
Tracked calls:
${trackedExpressionsMessage}
${delimiter}
`;
  }
};

// projects/moq/src/lib/verification/verify-error.ts
var VerifyError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// projects/moq/src/lib/verification/verification-tester.ts
var VerificationTester = class {
  constructor(verifyFormatter) {
    this.verifyFormatter = verifyFormatter;
  }
  test(expression, callCount, times) {
    const passed = times.test(callCount);
    if (passed === false) {
      const message = this.verifyFormatter.format(expression, times.message, callCount);
      throw new VerifyError(message);
    }
  }
};

// projects/moq/src/lib/expression.equality-comparers/expression.equality-comparer.ts
var ExpressionEqualityComparer = class {
  constructor(getPropertyExpressionMatcher, setPropertyExpressionMatcher, methodExpressionMatcher, namedMethodExpressionMatcher, inOperatorExpressionMatcher, newOperatorExpressionMatcher, itEqualityComparer) {
    this.getPropertyExpressionMatcher = getPropertyExpressionMatcher;
    this.setPropertyExpressionMatcher = setPropertyExpressionMatcher;
    this.methodExpressionMatcher = methodExpressionMatcher;
    this.namedMethodExpressionMatcher = namedMethodExpressionMatcher;
    this.inOperatorExpressionMatcher = inOperatorExpressionMatcher;
    this.newOperatorExpressionMatcher = newOperatorExpressionMatcher;
    this.itEqualityComparer = itEqualityComparer;
  }
  equals(left, right) {
    if (left === right)
      return true;
    if (left instanceof It || right instanceof It) {
      return this.itEqualityComparer.equals(left, right);
    }
    if (left instanceof GetPropertyExpression && right instanceof GetPropertyExpression) {
      return this.getPropertyExpressionMatcher.equals(left, right);
    }
    if (left instanceof SetPropertyExpression && right instanceof SetPropertyExpression) {
      return this.setPropertyExpressionMatcher.equals(left, right);
    }
    if (left instanceof InOperatorExpression && right instanceof InOperatorExpression) {
      return this.inOperatorExpressionMatcher.equals(left, right);
    }
    if (left instanceof FunctionExpression && right instanceof FunctionExpression) {
      return this.methodExpressionMatcher.equals(left, right);
    }
    if (left instanceof MethodExpression && right instanceof MethodExpression) {
      return this.namedMethodExpressionMatcher.equals(left, right);
    }
    if (left instanceof NewOperatorExpression && right instanceof NewOperatorExpression) {
      return this.newOperatorExpressionMatcher.equals(left, right);
    }
    return false;
  }
};

// projects/moq/src/lib/verification/index.ts
var verification_default = [
  { provide: Verifier, useClass: Verifier, deps: [CallCounter, VerificationTester, AutoMockProvider] },
  { provide: CallCounter, useClass: CallCounter, deps: [ExpressionEqualityComparer, Tracker] },
  { provide: VerificationTester, useClass: VerificationTester, deps: [VerifyFormatter] }
];

// projects/moq/src/lib/interceptors/apply.trap.ts
var ApplyTrap = class {
  constructor(tracker, interactionPlayer) {
    this.tracker = tracker;
    this.interactionPlayer = interactionPlayer;
  }
  intercept(target, thisArg, argArray) {
    const expression = new FunctionExpression(argArray);
    this.tracker.add(expression);
    return this.interactionPlayer.play(expression);
  }
};

// projects/moq/src/lib/interaction-players/interaction.player.ts
var InteractionPlayer = class {
  constructor(playablePresetProvider, presetPlayablesUpdater, presetPlayer) {
    this.playablePresetProvider = playablePresetProvider;
    this.presetPlayablesUpdater = presetPlayablesUpdater;
    this.presetPlayer = presetPlayer;
  }
  play(interaction) {
    const preset = this.playablePresetProvider.get(interaction);
    this.presetPlayablesUpdater.update(interaction, preset);
    if (preset === void 0)
      return void 0;
    return this.presetPlayer.play(preset, interaction);
  }
};

// projects/moq/src/lib/interceptors/get.trap.ts
var GetTrap = class {
  constructor(mock, tracker, propertiesValueStorage, interactionPlayer, hasPropertyExplorer, hasMethodExplorer, spyFunctionProvider) {
    this.mock = mock;
    this.tracker = tracker;
    this.propertiesValueStorage = propertiesValueStorage;
    this.interactionPlayer = interactionPlayer;
    this.hasPropertyExplorer = hasPropertyExplorer;
    this.hasMethodExplorer = hasMethodExplorer;
    this.spyFunctionProvider = spyFunctionProvider;
  }
  intercept(property) {
    const interaction = new GetPropertyExpression(property);
    this.tracker.add(interaction);
    if (property === MoqAPI) {
      return this.mock;
    }
    if (this.propertiesValueStorage.has(property)) {
      return this.propertiesValueStorage.get(property);
    }
    if (this.hasPropertyExplorer.has(property)) {
      return this.interactionPlayer.play(interaction);
    }
    if (this.hasMethodExplorer.has(property)) {
      return this.spyFunctionProvider.get(property);
    }
    return this.interactionPlayer.play(interaction);
  }
};

// projects/moq/src/lib/interceptors/properties-value.storage.ts
var PropertiesValueStorage = class {
  storage = /* @__PURE__ */ new Map();
  has(property) {
    return this.storage.has(property);
  }
  get(property) {
    return this.storage.get(property);
  }
  set(property, value) {
    this.storage.set(property, value);
  }
};

// projects/moq/src/lib/explorers/has-property.explorer/has-property.explorer.ts
var HasPropertyExplorer = class {
  constructor(presets, membersExplorer, explorer) {
    this.presets = presets;
    this.membersExplorer = membersExplorer;
    this.explorer = explorer;
  }
  has(name) {
    if (this.membersExplorer.hasProperty(name)) {
      return true;
    }
    return this.presets.get().find((preset) => this.explorer.has(name, preset)) !== void 0;
  }
};

// projects/moq/src/lib/explorers/has-method.explorer/has-method.explorer.ts
var HasMethodExplorer = class {
  constructor(presets, membersExplorer, explorer) {
    this.presets = presets;
    this.membersExplorer = membersExplorer;
    this.explorer = explorer;
  }
  has(name) {
    if (this.membersExplorer.hasMethod(name)) {
      return true;
    }
    return this.presets.get().find((preset) => this.explorer.has(name, preset)) !== void 0;
  }
};

// projects/moq/src/lib/interceptors/spy-function.provider.ts
var SpyFunctionProvider = class {
  constructor(tracker, interactionPlayer) {
    this.tracker = tracker;
    this.interactionPlayer = interactionPlayer;
  }
  map = /* @__PURE__ */ new Map();
  get(property) {
    if (this.map.has(property) === false) {
      this.map.set(property, (...args) => {
        const interaction = new MethodExpression(property, args);
        this.tracker.add(interaction);
        return this.interactionPlayer.play(interaction);
      });
    }
    return this.map.get(property);
  }
};

// projects/moq/src/lib/interceptors/get-prototype-of.trap.ts
var GetPrototypeOfTrap = class {
  constructor(prototypeStorage) {
    this.prototypeStorage = prototypeStorage;
  }
  intercept() {
    return this.prototypeStorage.get();
  }
};

// projects/moq/src/lib/interceptors/prototype.storage.ts
var PrototypeStorage = class {
  prototype = null;
  constructor(mockTarget) {
    this.prototype = mockTarget?.prototype ?? mockTarget;
  }
  get() {
    return this.prototype;
  }
  set(prototype) {
    this.prototype = prototype;
  }
};

// projects/moq/src/lib/interceptors/has.trap.ts
var HasTrap = class {
  constructor(tracker, propertiesValueStorage, interactionPlayer, inOperatorInteractionExplorer, hasPropertyExplorer, hasMethodExplorer, presetPlayablesUpdater) {
    this.tracker = tracker;
    this.propertiesValueStorage = propertiesValueStorage;
    this.interactionPlayer = interactionPlayer;
    this.inOperatorInteractionExplorer = inOperatorInteractionExplorer;
    this.hasPropertyExplorer = hasPropertyExplorer;
    this.hasMethodExplorer = hasMethodExplorer;
    this.presetPlayablesUpdater = presetPlayablesUpdater;
  }
  intercept(property) {
    const interaction = new InOperatorExpression(property);
    this.tracker.add(interaction);
    if (this.propertiesValueStorage.has(property)) {
      return true;
    }
    if (this.inOperatorInteractionExplorer.has(property)) {
      return this.interactionPlayer.play(interaction);
    }
    this.presetPlayablesUpdater.update(interaction, void 0);
    if (this.hasPropertyExplorer.has(property)) {
      return true;
    }
    if (this.hasMethodExplorer.has(property)) {
      return true;
    }
    return false;
  }
};

// projects/moq/src/lib/explorers/in-operator-interaction.explorer/in-operator-interaction.explorer.ts
var InOperatorInteractionExplorer = class {
  constructor(presets, explorer) {
    this.presets = presets;
    this.explorer = explorer;
  }
  has(name) {
    return this.presets.get().find((preset) => this.explorer.has(name, preset)) !== void 0;
  }
};

// projects/moq/src/lib/playables/preset-playables.updater.ts
var PresetPlayablesUpdater = class {
  constructor(presets, matcher) {
    this.presets = presets;
    this.matcher = matcher;
  }
  update(interaction, playable) {
    for (const preset of this.presets.get()) {
      const { target, playable: { update } } = preset;
      if (this.matcher.equals(interaction, target)) {
        const reason = preset === playable ? 0 /* OwnSetupWouldBePlayed */ : 1 /* OtherSetupWouldBePlayed */;
        update(reason);
      }
    }
  }
};

// projects/moq/src/lib/interceptors/set.trap.ts
var SetTrap = class {
  constructor(tracker, propertiesValueStorage, interactionPlayer, propertyIsReadOnlyTester) {
    this.tracker = tracker;
    this.propertiesValueStorage = propertiesValueStorage;
    this.interactionPlayer = interactionPlayer;
    this.propertyIsReadOnlyTester = propertyIsReadOnlyTester;
  }
  intercept(target, property, value) {
    const expression = new SetPropertyExpression(property, value);
    this.tracker.add(expression);
    if (property === MoqAPI) {
      return false;
    }
    if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {
      return false;
    }
    const accepted = this.interactionPlayer.play(expression);
    if (accepted === true || accepted === void 0) {
      this.propertiesValueStorage.set(property, value);
    }
    return accepted === void 0 ? true : accepted;
  }
};

// projects/moq/src/lib/interceptors/set-prototype-of.trap.ts
var SetPrototypeOfTrap = class {
  constructor(prototypeStorage) {
    this.prototypeStorage = prototypeStorage;
  }
  intercept(prototype) {
    if (prototype !== void 0) {
      this.prototypeStorage.set(prototype);
      return true;
    }
    return false;
  }
};

// projects/moq/src/lib/interceptors/proxy.factory.ts
var ProxyFactory = class {
  constructor(options, getTrap, setTrap, hasTrap, applyTrap, getPrototypeOfTrap, setPrototypeOfTrap, constructTrap) {
    this.options = options;
    this.getTrap = getTrap;
    this.setTrap = setTrap;
    this.hasTrap = hasTrap;
    this.applyTrap = applyTrap;
    this.getPrototypeOfTrap = getPrototypeOfTrap;
    this.setPrototypeOfTrap = setPrototypeOfTrap;
    this.constructTrap = constructTrap;
  }
  _proxy;
  object() {
    if (this._proxy === void 0) {
      this._proxy = this.createObject();
    }
    return this._proxy;
  }
  createObject() {
    const options = {
      get: (target, name) => this.getTrap.intercept(name),
      set: (target, name, value) => this.setTrap.intercept(target, name, value),
      has: (target, name) => this.hasTrap.intercept(name),
      apply: (target, thisArg, args) => this.applyTrap.intercept(target, thisArg, args),
      getPrototypeOf: () => this.getPrototypeOfTrap.intercept(),
      setPrototypeOf: (target, prototype) => this.setPrototypeOfTrap.intercept(prototype),
      construct: (target, args) => this.constructTrap.intercept(args)
    };
    if (this.options.name) {
      options["mockName"] = this.options.name;
    }
    return new Proxy(this.options.target, options);
  }
};

// projects/moq/src/lib/mock-options/mock-options.injection-token.ts
var MOCK_OPTIONS = new InjectionToken("mock options");

// projects/moq/src/lib/explorers/has-property.explorer/property-is-read-only.tester.ts
var PropertyIsReadOnlyTester = class {
  constructor(storage, propertyDescriptorProvider, has) {
    this.storage = storage;
    this.propertyDescriptorProvider = propertyDescriptorProvider;
    this.has = has;
  }
  isReadOnly(name) {
    const prototype = this.storage.get();
    if (prototype && this.has(prototype, name)) {
      const descriptor = this.propertyDescriptorProvider.get(prototype, name);
      return descriptor.get instanceof Function && descriptor.set === void 0 || descriptor.writable === false;
    }
    return false;
  }
};

// projects/moq/src/lib/interceptors/construct.trap.ts
var ConstructTrap = class {
  constructor(tracker, interactionPlayer) {
    this.tracker = tracker;
    this.interactionPlayer = interactionPlayer;
  }
  intercept(args) {
    const interaction = new NewOperatorExpression(args);
    this.tracker.add(interaction);
    return this.interactionPlayer.play(interaction);
  }
};

// projects/moq/src/lib/interceptors/index.ts
var interceptors_default = [
  {
    provide: ProxyFactory,
    useClass: ProxyFactory,
    deps: [
      MOCK_OPTIONS,
      GetTrap,
      SetTrap,
      HasTrap,
      ApplyTrap,
      GetPrototypeOfTrap,
      SetPrototypeOfTrap,
      ConstructTrap
    ]
  },
  { provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer] },
  {
    provide: GetTrap,
    useClass: GetTrap,
    deps: [
      MOCK,
      Tracker,
      PropertiesValueStorage,
      InteractionPlayer,
      HasPropertyExplorer,
      HasMethodExplorer,
      SpyFunctionProvider
    ]
  },
  { provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage] },
  {
    provide: HasTrap,
    useClass: HasTrap,
    deps: [
      Tracker,
      PropertiesValueStorage,
      InteractionPlayer,
      InOperatorInteractionExplorer,
      HasPropertyExplorer,
      HasMethodExplorer,
      PresetPlayablesUpdater
    ]
  },
  { provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: [] },
  { provide: PrototypeStorage, useFactory: ({ target }) => new PrototypeStorage(target), deps: [MOCK_OPTIONS] },
  {
    provide: SetTrap,
    useClass: SetTrap,
    deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester]
  },
  { provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage] },
  { provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer] },
  { provide: ConstructTrap, useClass: ConstructTrap, deps: [Tracker, InteractionPlayer] }
];

// projects/moq/src/lib/playables/index.ts
var playables_default = [
  { provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionEqualityComparer] }
];

// projects/moq/src/lib/interaction-players/preset.player.ts
var PresetPlayer = class {
  constructor(callbackPresetPlayer, mimicsPresetPlayer) {
    this.callbackPresetPlayer = callbackPresetPlayer;
    this.mimicsPresetPlayer = mimicsPresetPlayer;
  }
  play(preset, interaction) {
    if (preset instanceof ReturnsPreset) {
      return preset.value;
    }
    if (preset instanceof CallbacksPreset) {
      return this.callbackPresetPlayer.play(preset.callback, interaction);
    }
    if (preset instanceof MimicsPreset) {
      return this.mimicsPresetPlayer.play(preset.origin, interaction);
    }
    if (preset instanceof ThrowsPreset) {
      throw preset.exception;
    }
  }
};

// projects/moq/src/lib/interaction-players/callback-preset.player.ts
var CallbackPresetPlayer = class {
  play(callback, interaction) {
    return callback.apply(void 0, [interaction]);
  }
};

// projects/moq/src/lib/interaction-players/mimics-preset.player.ts
var MimicsPresetPlayer = class {
  constructor(apply) {
    this.apply = apply;
  }
  play(origin, interaction) {
    if (interaction instanceof GetPropertyExpression) {
      return origin[interaction.name];
    }
    if (interaction instanceof SetPropertyExpression) {
      origin[interaction.name] = interaction.value;
      return true;
    }
    if (interaction instanceof MethodExpression) {
      const method = origin[interaction.name];
      return this.apply(method, origin, interaction.args);
    }
    if (interaction instanceof FunctionExpression) {
      return this.apply(origin, void 0, interaction.args);
    }
    if (interaction instanceof InOperatorExpression) {
      return interaction.name in origin;
    }
    if (interaction instanceof NewOperatorExpression) {
      return new origin(...interaction.args);
    }
  }
};

// projects/moq/src/lib/interaction-players/playable-preset.provider.ts
var PlayablePresetProvider = class {
  constructor(presets, matcher) {
    this.presets = presets;
    this.matcher = matcher;
  }
  get(interaction) {
    for (const preset of this.presets.get()) {
      const { target, playable: { isPlayable } } = preset;
      if (this.matcher.equals(interaction, target) && isPlayable() === true) {
        return preset;
      }
    }
  }
};

// projects/moq/src/lib/interaction-players/reflect-apply.injection-token.ts
var REFLECT_APPLY = new InjectionToken("Reflect Apply");

// projects/moq/src/lib/interaction-players/index.ts
var interaction_players_default = [
  { provide: REFLECT_APPLY, useValue: Reflect.apply, deps: [] },
  { provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer] },
  { provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionEqualityComparer] },
  { provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY] },
  {
    provide: InteractionPlayer,
    useClass: InteractionPlayer,
    deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]
  },
  { provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: [] }
];

// projects/moq/src/lib/formatters/expressions.formatter.ts
var ExpressionsFormatter = class {
  constructor(interactionFormatter, options) {
    this.interactionFormatter = interactionFormatter;
    this.options = options;
  }
  format(expression, timesMessage, haveBeenCalledTimes) {
    const expressionDescription = this.interactionFormatter.format(expression);
    const mockName = this.options.name;
    const mockDescription = mockName !== void 0 ? ` of ${mockName}` : "";
    return `${expressionDescription}${mockDescription} ${timesMessage.toLowerCase()}, but was called ${haveBeenCalledTimes} time(s)`;
  }
};

// projects/moq/src/lib/formatters/interaction.formatter.ts
var InteractionFormatter = class {
  constructor(getPropertyFormatter, setPropertyFormatter, methodFormatter, namedMethodFormatter, constantFormatter, inOperatorFormatter, newOperatorFormatter) {
    this.getPropertyFormatter = getPropertyFormatter;
    this.setPropertyFormatter = setPropertyFormatter;
    this.methodFormatter = methodFormatter;
    this.namedMethodFormatter = namedMethodFormatter;
    this.constantFormatter = constantFormatter;
    this.inOperatorFormatter = inOperatorFormatter;
    this.newOperatorFormatter = newOperatorFormatter;
  }
  format(interaction) {
    if (interaction instanceof GetPropertyExpression)
      return this.getPropertyFormatter.format(interaction);
    if (interaction instanceof SetPropertyExpression)
      return this.setPropertyFormatter.format(interaction);
    if (interaction instanceof InOperatorExpression)
      return this.inOperatorFormatter.format(interaction);
    if (interaction instanceof FunctionExpression)
      return this.methodFormatter.format(interaction);
    if (interaction instanceof MethodExpression)
      return this.namedMethodFormatter.format(interaction);
    if (interaction instanceof NewOperatorExpression)
      return this.newOperatorFormatter.format(interaction);
    if (interaction instanceof It)
      return this.constantFormatter.format(interaction);
    return void 0;
  }
};

// projects/moq/src/lib/formatters/set-property.formatter.ts
var SetPropertyFormatter = class {
  constructor(constantFormatter, propertyKeyFormatter) {
    this.constantFormatter = constantFormatter;
    this.propertyKeyFormatter = propertyKeyFormatter;
  }
  format(expression) {
    const value = this.constantFormatter.format(expression.value);
    const propertyKey = this.propertyKeyFormatter.format(expression.name);
    return `Assignment of ${value} to property '${propertyKey}'`;
  }
};

// projects/moq/src/lib/formatters/constant.formatter.ts
var ConstantFormatter = class {
  format(object) {
    if (object instanceof It)
      return `It.Is(${object.predicate})`;
    if (object instanceof String || typeof object === "string")
      return `'${object}'`;
    if (object instanceof Array) {
      const description = [];
      for (const value of object) {
        description.push(this.format(value));
      }
      return `[${description}]`;
    }
    return `${object}`;
  }
};

// projects/moq/src/lib/formatters/property-key.formatter.ts
var PropertyKeyFormatter = class {
  format(property) {
    return String(property);
  }
};

// projects/moq/src/lib/formatters/method.formatter.ts
var MethodFormatter = class {
  constructor(constantFormatter, propertyKeyFormatter) {
    this.constantFormatter = constantFormatter;
    this.propertyKeyFormatter = propertyKeyFormatter;
  }
  format(expression) {
    const formatted = [];
    for (const arg of expression.args) {
      formatted.push(this.constantFormatter.format(arg));
    }
    const value = formatted.join(", ");
    const propertyKey = this.propertyKeyFormatter.format(expression.name);
    return `${propertyKey}(${value})`;
  }
};

// projects/moq/src/lib/formatters/function.formatter.ts
var FunctionFormatter = class {
  constructor(constantFormatter) {
    this.constantFormatter = constantFormatter;
  }
  format(expression) {
    const value = this.constantFormatter.format(expression.args);
    return `(${value})`;
  }
};

// projects/moq/src/lib/formatters/in-operator.formatter.ts
var InOperatorFormatter = class {
  constructor(propertyKeyFormatter) {
    this.propertyKeyFormatter = propertyKeyFormatter;
  }
  format(expression) {
    const propertyKey = this.propertyKeyFormatter.format(expression.name);
    return `In operator for '${propertyKey}'`;
  }
};

// projects/moq/src/lib/formatters/get-property.formatter.ts
var GetPropertyFormatter = class {
  constructor(propertyKeyFormatter) {
    this.propertyKeyFormatter = propertyKeyFormatter;
  }
  format(interaction) {
    const propertyKey = this.propertyKeyFormatter.format(interaction.name);
    return `Getter of '${propertyKey}'`;
  }
};

// projects/moq/src/lib/formatters/new-operator.formatter.ts
var NewOperatorFormatter = class {
  constructor(constantFormatter) {
    this.constantFormatter = constantFormatter;
  }
  format(expression) {
    const value = this.constantFormatter.format(expression.args);
    return `new constructor(${value})`;
  }
};

// projects/moq/src/lib/formatters/index.ts
var formatters_default = [
  {
    provide: VerifyFormatter,
    useClass: VerifyFormatter,
    deps: [ExpressionsFormatter, TrackedExpressionsFormatter, Tracker]
  },
  { provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [InteractionFormatter] },
  { provide: SetPropertyFormatter, useClass: SetPropertyFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
  { provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: [] },
  { provide: MethodFormatter, useClass: MethodFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
  { provide: FunctionFormatter, useClass: FunctionFormatter, deps: [ConstantFormatter] },
  { provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter] },
  { provide: GetPropertyFormatter, useClass: GetPropertyFormatter, deps: [PropertyKeyFormatter] },
  { provide: ExpressionsFormatter, useClass: ExpressionsFormatter, deps: [InteractionFormatter, MOCK_OPTIONS] },
  { provide: ConstantFormatter, useClass: ConstantFormatter, deps: [] },
  { provide: NewOperatorFormatter, useClass: NewOperatorFormatter, deps: [ConstantFormatter] },
  {
    provide: InteractionFormatter,
    useClass: InteractionFormatter,
    deps: [
      GetPropertyFormatter,
      SetPropertyFormatter,
      FunctionFormatter,
      MethodFormatter,
      ConstantFormatter,
      InOperatorFormatter,
      NewOperatorFormatter
    ]
  }
];

// projects/moq/src/lib/explorers/has-method.explorer/expression.has-method.explorer.ts
var ExpressionHasMethodExplorer = class {
  has(name, expression) {
    if (expression instanceof MethodExpression) {
      return expression.name === name;
    }
    return false;
  }
};

// projects/moq/src/lib/explorers/members.explorer/members-method.explorer.ts
var MembersMethodExplorer = class {
  constructor(storage, propertyDescriptorProvider, has) {
    this.storage = storage;
    this.propertyDescriptorProvider = propertyDescriptorProvider;
    this.has = has;
  }
  hasMethod(name) {
    const prototype = this.storage.get();
    if (prototype && this.has(prototype, name)) {
      const descriptor = this.propertyDescriptorProvider.get(prototype, name);
      return descriptor.value instanceof Function;
    }
    return false;
  }
};

// projects/moq/src/lib/explorers/has-method.explorer/preset.has-method.explorer.ts
var PresetHasMethodExplorer = class {
  constructor(expressionHasMethodExplorer, objectHasMethodExplorer) {
    this.expressionHasMethodExplorer = expressionHasMethodExplorer;
    this.objectHasMethodExplorer = objectHasMethodExplorer;
  }
  has(name, preset) {
    if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {
      return true;
    }
    return this.expressionHasMethodExplorer.has(name, preset.target);
  }
};

// projects/moq/src/lib/explorers/has-method.explorer/object.has-method.explorer.ts
var ObjectHasMethodExplorer = class {
  has(name, target) {
    return target[name] instanceof Function;
  }
};

// projects/moq/src/lib/explorers/has-property.explorer/expression-has-property.explorer.ts
var ExpressionHasPropertyExplorer = class {
  has(name, expression) {
    if (expression instanceof It || expression instanceof FunctionExpression || expression instanceof MethodExpression || expression instanceof InOperatorExpression) {
      return false;
    }
    return expression.name === name;
  }
};

// projects/moq/src/lib/explorers/members.explorer/members-property.explorer.ts
var MembersPropertyExplorer = class {
  constructor(storage, propertyDescriptorProvider, has) {
    this.storage = storage;
    this.propertyDescriptorProvider = propertyDescriptorProvider;
    this.has = has;
  }
  hasProperty(name) {
    const prototype = this.storage.get();
    if (prototype && this.has(prototype, name)) {
      const descriptor = this.propertyDescriptorProvider.get(prototype, name);
      return descriptor.get !== void 0 || descriptor.value instanceof Function === false;
    }
    return false;
  }
};

// projects/moq/src/lib/explorers/has-property.explorer/preset-has-property.explorer.ts
var PresetHasPropertyExplorer = class {
  constructor(expressionHasPropertyExplorer, objectHasPropertyExplorer) {
    this.expressionHasPropertyExplorer = expressionHasPropertyExplorer;
    this.objectHasPropertyExplorer = objectHasPropertyExplorer;
  }
  has(name, preset) {
    if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {
      return true;
    }
    return this.expressionHasPropertyExplorer.has(name, preset.target);
  }
};

// projects/moq/src/lib/explorers/has-property.explorer/object-has-property.explorer.ts
var ObjectHasPropertyExplorer = class {
  has(name, target) {
    return Reflect.has(target, name) && target[name] instanceof Function === false;
  }
};

// projects/moq/src/lib/explorers/in-operator-interaction.explorer/preset.has-in-operator.explorer.ts
var PresetHasInOperatorExplorer = class {
  has(name, preset) {
    const { playable: { isPlayable } } = preset;
    if (isPlayable() === false) {
      return false;
    }
    if (preset.target instanceof InOperatorExpression) {
      return preset.target.name === name;
    }
    if (preset.target instanceof It) {
      return preset.target.test(new InOperatorExpression(name));
    }
    return false;
  }
};

// projects/moq/src/lib/explorers/members.explorer/property-descriptor.provider.ts
var PropertyDescriptorProvider = class {
  get(target, name) {
    let prototype = target;
    while (prototype !== null) {
      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);
      if (descriptor !== void 0)
        return descriptor;
      prototype = Reflect.getPrototypeOf(prototype);
    }
  }
};

// projects/moq/src/lib/explorers/reflect-has.injection-token.ts
var REFLECT_HAS = new InjectionToken("Reflect has");

// projects/moq/src/lib/explorers/index.ts
var explorers_default = [
  { provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: [] },
  {
    provide: HasMethodExplorer,
    useClass: HasMethodExplorer,
    deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]
  },
  { provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: [] },
  {
    provide: PresetHasMethodExplorer,
    useClass: PresetHasMethodExplorer,
    deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]
  },
  { provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: [] },
  {
    provide: HasPropertyExplorer,
    useClass: HasPropertyExplorer,
    deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]
  },
  { provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: [] },
  {
    provide: PresetHasPropertyExplorer,
    useClass: PresetHasPropertyExplorer,
    deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]
  },
  {
    provide: InOperatorInteractionExplorer,
    useClass: InOperatorInteractionExplorer,
    deps: [Presets, PresetHasInOperatorExplorer]
  },
  { provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: [] },
  {
    provide: MembersMethodExplorer,
    useClass: MembersMethodExplorer,
    deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
  },
  {
    provide: PropertyIsReadOnlyTester,
    useClass: PropertyIsReadOnlyTester,
    deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
  },
  {
    provide: MembersPropertyExplorer,
    useClass: MembersPropertyExplorer,
    deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
  },
  { provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: [] },
  { provide: REFLECT_HAS, useValue: Reflect.has, deps: [] }
];

// projects/moq/src/lib/mock-options/mock-options.builder.ts
var MockOptionsBuilder = class {
  build(options) {
    const target = () => void 0;
    return { target, ...options };
  }
};

// projects/moq/src/lib/mock-options/mock-options.providers.ts
function mockOptionsProviders(options) {
  return [
    { provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: [] },
    { provide: MOCK_OPTIONS, useFactory: (builder) => builder.build(options), deps: [MockOptionsBuilder] }
  ];
}

// projects/moq/src/lib/core/mock-core.ts
var MockCore = class {
  constructor(options, tracker, injector, reflector, interceptor, verifier, prototypeStorage, mock, setupFactory) {
    this.options = options;
    this.tracker = tracker;
    this.injector = injector;
    this.reflector = reflector;
    this.interceptor = interceptor;
    this.verifier = verifier;
    this.prototypeStorage = prototypeStorage;
    this.mock = mock;
    this.setupFactory = setupFactory;
  }
  get name() {
    return this.options.name;
  }
  resolve(token) {
    return this.injector.get(token, null);
  }
  setup(expression) {
    const expressions = this.reflector.reflect(expression);
    return this.setupFactory.create(expressions);
  }
  verify(expression, times) {
    const expressions = this.reflector.reflect(expression);
    this.verifier.test(expressions, times);
    return this.mock;
  }
  object() {
    return this.interceptor.object();
  }
  prototypeof(prototype) {
    this.prototypeStorage.set(prototype);
    return this.mock;
  }
  /**
   * @experimental
   */
  insequence(sequence, expression) {
    sequence.add(this, expression);
    return this.mock;
  }
};

// projects/moq/src/lib/core/index.ts
var core_default = [
  {
    provide: MockCore,
    useClass: MockCore,
    deps: [
      MOCK_OPTIONS,
      Tracker,
      Injector,
      EXPRESSION_REFLECTOR,
      ProxyFactory,
      Verifier,
      PrototypeStorage,
      MOCK,
      SetupFactory
    ]
  }
];

// projects/moq/src/lib/auto-mocking/auto-mock.factory.ts
var AutoMockFactory = class {
  constructor(ctor, optionsBuilder) {
    this.ctor = ctor;
    this.optionsBuilder = optionsBuilder;
  }
  create(expression) {
    const options = this.optionsBuilder.create(expression);
    return this.ctor(options);
  }
};

// projects/moq/src/lib/injector/root-mock.injection-token.ts
var ROOT_MOCK = new InjectionToken("ROOT MOCK");

// projects/moq/src/lib/auto-mocking/auto-mock.storage.ts
var AutoMockedStorage = class {
  constructor() {
    return this.factory();
  }
  factory() {
    return /* @__PURE__ */ new Map();
  }
};

// projects/moq/src/lib/auto-mocking/auto-mock-options.builder.ts
var AutoMockOptionsBuilder = class {
  constructor(options, autoMockNameFormatter, autoMockInjectorConfig) {
    this.options = options;
    this.autoMockNameFormatter = autoMockNameFormatter;
    this.autoMockInjectorConfig = autoMockInjectorConfig;
  }
  create(expression) {
    return {
      name: this.autoMockNameFormatter.format(this.options.name, expression),
      target: this.options.target,
      injectorConfig: this.autoMockInjectorConfig
    };
  }
};

// projects/moq/src/lib/auto-mocking/name-formatters/auto-mock-name.formatter.ts
var AutoMockNameFormatter = class {
  constructor(namePrefixProvider, methodFormatter, propertyKeyFormatter, namedMethodFormatter, constantFormatter) {
    this.namePrefixProvider = namePrefixProvider;
    this.methodFormatter = methodFormatter;
    this.propertyKeyFormatter = propertyKeyFormatter;
    this.namedMethodFormatter = namedMethodFormatter;
    this.constantFormatter = constantFormatter;
  }
  format(name, expression) {
    const prefix = this.namePrefixProvider.get(name);
    if (expression instanceof FunctionExpression) {
      return `${prefix}${this.methodFormatter.format(expression)}`;
    }
    if (expression instanceof GetPropertyExpression) {
      return `${prefix}.${this.propertyKeyFormatter.format(expression.name)}`;
    }
    if (expression instanceof MethodExpression) {
      return `${prefix}.${this.namedMethodFormatter.format(expression)}`;
    }
    if (expression instanceof NewOperatorExpression) {
      return `new ${name}(${this.constantFormatter.format(expression.args)})`;
    }
    return `${name}[${expression}]`;
  }
};

// projects/moq/src/lib/auto-mocking/auto-mock-injector.config.ts
var AutoMockInjectorConfig = class {
  constructor(options, mock, root) {
    this.options = options;
    this.mock = mock;
    this.root = root;
  }
  get(options, providers) {
    if (this.root) {
      return this.options.injectorConfig.get(options, providers);
    }
    return [
      ...this.options.injectorConfig.get(options, providers),
      { provide: ROOT_MOCK, useValue: this.mock, deps: [] }
    ];
  }
};

// projects/moq/src/lib/auto-mocking/name-formatters/name-prefix.provider.ts
var NamePrefixProvider = class {
  get(name) {
    return name ? name : "instance";
  }
};

// projects/moq/src/lib/injector/mock-constructor.injection-token.ts
var MOCK_CONSTRUCTOR = new InjectionToken("IMock constructor");

// projects/moq/src/lib/auto-mocking/expression.guards/complex-expression.validator.ts
var ComplexExpressionValidator = class {
  constructor(validator) {
    this.validator = validator;
  }
  validate(expressions) {
    const errors = [];
    const clone = [...expressions];
    const last = clone.pop();
    for (const expression of clone) {
      errors.push([expression, this.validator.validate(expression)]);
    }
    errors.push([last, true]);
    const isValid = errors.filter(([, valid]) => valid === false).length === 0;
    return {
      valid: isValid,
      errors: isValid ? [] : errors
    };
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression-guard-exception.factory.ts
var ExpressionGuardExceptionFactory = class {
  constructor(formatter) {
    this.formatter = formatter;
  }
  create(expressions) {
    const message = `${this.formatter.format(expressions)} is not a safe expression for auto mocking.  It predicate could not be used, the only exception is the last part. Please see https://github.com/dvabuzyarov/moq.ts#auto-mocking for more details.`;
    return new Error(message);
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression.validator.ts
var ExpressionValidator = class {
  constructor(functionExpressionGuard, getPropertyExpressionGuard, setPropertyExpressionGuard, inOperatorExpressionGuard, instanceMethodExpressionGuard, newOperatorExpressionGuard) {
    this.functionExpressionGuard = functionExpressionGuard;
    this.getPropertyExpressionGuard = getPropertyExpressionGuard;
    this.setPropertyExpressionGuard = setPropertyExpressionGuard;
    this.inOperatorExpressionGuard = inOperatorExpressionGuard;
    this.instanceMethodExpressionGuard = instanceMethodExpressionGuard;
    this.newOperatorExpressionGuard = newOperatorExpressionGuard;
  }
  validate(expression) {
    switch (expression.constructor) {
      case FunctionExpression:
        return this.functionExpressionGuard.validate(expression);
      case GetPropertyExpression:
        return this.getPropertyExpressionGuard.validate(expression);
      case SetPropertyExpression:
        return this.setPropertyExpressionGuard.validate(expression);
      case InOperatorExpression:
        return this.inOperatorExpressionGuard.validate(expression);
      case MethodExpression:
        return this.instanceMethodExpressionGuard.validate(expression);
      case NewOperatorExpression:
        return this.newOperatorExpressionGuard.validate(expression);
      case It:
        return false;
      default:
        throw new Error(`Unknown expression type: ${expression.constructor.name}`);
    }
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/function-expression.validator.ts
var FunctionExpressionValidator = class {
  validate({ args }) {
    return args.filter((arg) => arg instanceof It).length === 0;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/get-property-expression.validator.ts
var GetPropertyExpressionValidator = class {
  validate({ name }) {
    return name instanceof It === false;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/set-property-expression.validator.ts
var SetPropertyExpressionValidator = class {
  validate({ name, value }) {
    return (name instanceof It || value instanceof It) === false;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/in-operator-expression.validator.ts
var InOperatorExpressionValidator = class {
  validate({ name }) {
    return name instanceof It === false;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/instance-method-expression.validator.ts
var InstanceMethodExpressionValidator = class {
  validate({ name, args }) {
    return (name instanceof It || args.filter((arg) => arg instanceof It).length > 0) === false;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/new-operator-expression.validator.ts
var NewOperatorExpressionValidator = class {
  validate({ args }) {
    return args.filter((arg) => arg instanceof It).length === 0;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression.formatters/complex-expression.error-formatter.ts
var ComplexExpressionErrorFormatter = class {
  constructor(options, namePrefixProvider, expressionFormatter, errorStyler) {
    this.options = options;
    this.namePrefixProvider = namePrefixProvider;
    this.expressionFormatter = expressionFormatter;
    this.errorStyler = errorStyler;
  }
  format(expressions) {
    const instance = this.namePrefixProvider.get(this.options.name);
    let message = instance;
    for (const [expression, valid] of expressions) {
      const value = this.expressionFormatter.format(expression, instance);
      message += valid ? value : this.errorStyler.style(value);
    }
    return message;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression.formatters/expression.formatter.ts
var ExpressionFormatter = class {
  constructor(functionFormatter, propertyKeyFormatter, instanceMethodFormatter, constantFormatter) {
    this.functionFormatter = functionFormatter;
    this.propertyKeyFormatter = propertyKeyFormatter;
    this.instanceMethodFormatter = instanceMethodFormatter;
    this.constantFormatter = constantFormatter;
  }
  format(expression, name) {
    if (expression instanceof FunctionExpression) {
      return this.functionFormatter.format(expression);
    }
    if (expression instanceof GetPropertyExpression) {
      return `.${this.propertyKeyFormatter.format(expression.name)}`;
    }
    if (expression instanceof MethodExpression) {
      return `.${this.instanceMethodFormatter.format(expression)}`;
    }
    if (expression instanceof NewOperatorExpression) {
      return `new ${name}(${this.constantFormatter.format(expression.args)})`;
    }
    return `[${expression}]`;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression.formatters/string.error-styler.ts
var StringErrorStyler = class {
  style(value) {
    return `\x1B[4m${value}\x1B[24m`;
  }
};

// projects/moq/src/lib/auto-mocking/expression.guards/expression.formatters/index.ts
var expression_default = [
  {
    provide: ComplexExpressionErrorFormatter,
    useClass: ComplexExpressionErrorFormatter,
    deps: [
      MOCK_OPTIONS,
      NamePrefixProvider,
      ExpressionFormatter,
      StringErrorStyler
    ]
  },
  {
    provide: ExpressionFormatter,
    useClass: ExpressionFormatter,
    deps: [FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
  },
  { provide: StringErrorStyler, useClass: StringErrorStyler, deps: [] }
];

// projects/moq/src/lib/auto-mocking/expression.guards/index.ts
var expression_default2 = [
  {
    provide: ComplexExpressionGuard,
    useClass: ComplexExpressionGuard,
    deps: [ComplexExpressionValidator, ExpressionGuardExceptionFactory]
  },
  { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [ExpressionValidator] },
  {
    provide: ExpressionGuardExceptionFactory,
    useClass: ExpressionGuardExceptionFactory,
    deps: [ComplexExpressionErrorFormatter]
  },
  {
    provide: ExpressionValidator,
    useClass: ExpressionValidator,
    deps: [
      FunctionExpressionValidator,
      GetPropertyExpressionValidator,
      SetPropertyExpressionValidator,
      InOperatorExpressionValidator,
      InstanceMethodExpressionValidator,
      NewOperatorExpressionValidator
    ]
  },
  { provide: FunctionExpressionValidator, useClass: FunctionExpressionValidator, deps: [] },
  { provide: GetPropertyExpressionValidator, useClass: GetPropertyExpressionValidator, deps: [] },
  { provide: SetPropertyExpressionValidator, useClass: SetPropertyExpressionValidator, deps: [] },
  { provide: InOperatorExpressionValidator, useClass: InOperatorExpressionValidator, deps: [] },
  { provide: InstanceMethodExpressionValidator, useClass: InstanceMethodExpressionValidator, deps: [] },
  { provide: NewOperatorExpressionValidator, useClass: NewOperatorExpressionValidator, deps: [] },
  ...expression_default
];

// projects/moq/src/lib/auto-mocking/index.ts
var auto_mocking_default = [
  { provide: NamePrefixProvider, useClass: NamePrefixProvider, deps: [] },
  { provide: AutoMockedStorage, useClass: AutoMockedStorage, deps: [] },
  {
    provide: AutoMockNameFormatter,
    useClass: AutoMockNameFormatter,
    deps: [NamePrefixProvider, FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
  },
  {
    provide: AutoMockOptionsBuilder,
    useClass: AutoMockOptionsBuilder,
    deps: [MOCK_OPTIONS, AutoMockNameFormatter, AutoMockInjectorConfig]
  },
  {
    provide: AutoMockInjectorConfig,
    useClass: AutoMockInjectorConfig,
    deps: [MOCK_OPTIONS, MOCK, [new Optional(), ROOT_MOCK]]
  },
  { provide: AutoMockFactory, useClass: AutoMockFactory, deps: [MOCK_CONSTRUCTOR, AutoMockOptionsBuilder] },
  { provide: RootMockProvider, useClass: RootMockProvider, deps: [MOCK, [new Optional(), ROOT_MOCK]] },
  {
    provide: AutoMockProvider,
    useClass: AutoMockProvider,
    deps: [AutoMockedStorage, ExpressionEqualityComparer, AutoMockFactory]
  },
  { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [] },
  ...expression_default2
];

// projects/moq/src/lib/expression.equality-comparers/constant.equality-comparer.ts
var ConstantEqualityComparer = class {
  constructor(itEqualityComparer) {
    this.itEqualityComparer = itEqualityComparer;
  }
  equals(left, right) {
    const actual = this.itEqualityComparer.equals(left, right);
    return actual === void 0 ? left === right : actual;
  }
};

// projects/moq/src/lib/expression.equality-comparers/arguments.equality-comparer.ts
var ArgumentsEqualityComparer = class {
  constructor(constantMatcher) {
    this.constantMatcher = constantMatcher;
  }
  equals(left, right) {
    if (left === right)
      return true;
    if (left.length !== right.length)
      return false;
    for (let i = 0; i < left.length; i++) {
      const lvalue = left[i];
      const rvalue = right[i];
      if (this.constantMatcher.equals(lvalue, rvalue) === false) {
        return false;
      }
    }
    return true;
  }
};

// projects/moq/src/lib/expression.equality-comparers/get-property.equality-comparer.ts
var GetPropertyEqualityComparer = class {
  equals(left, right) {
    return left.name === right.name;
  }
};

// projects/moq/src/lib/expression.equality-comparers/in-operator.equality-comparer.ts
var InOperatorEqualityComparer = class {
  equals(left, right) {
    return left.name === right.name;
  }
};

// projects/moq/src/lib/expression.equality-comparers/instance-method.equality-comparer.ts
var InstanceMethodEqualityComparer = class {
  constructor(argumentsMatcher) {
    this.argumentsMatcher = argumentsMatcher;
  }
  equals(left, right) {
    return left.name === right.name && this.argumentsMatcher.equals(left.args, right.args);
  }
};

// projects/moq/src/lib/expression.equality-comparers/it.equality-comparer.ts
var ItEqualityComparer = class {
  equals(left, right) {
    if (left instanceof It && right instanceof It) {
      return left === right || left.predicate === right.predicate;
    }
    if (left instanceof It) {
      return left.test(right);
    }
    if (right instanceof It) {
      return right.test(left);
    }
    return void 0;
  }
};

// projects/moq/src/lib/expression.equality-comparers/method.equality-comparer.ts
var MethodEqualityComparer = class {
  constructor(argumentsMatcher) {
    this.argumentsMatcher = argumentsMatcher;
  }
  equals(left, right) {
    return this.argumentsMatcher.equals(left.args, right.args);
  }
};

// projects/moq/src/lib/expression.equality-comparers/new-operator.equality-comparer.ts
var NewOperatorEqualityComparer = class {
  constructor(argumentsMatcher) {
    this.argumentsMatcher = argumentsMatcher;
  }
  equals(left, right) {
    return this.argumentsMatcher.equals(left.args, right.args);
  }
};

// projects/moq/src/lib/expression.equality-comparers/set-property.equality-comparer.ts
var SetPropertyEqualityComparer = class {
  constructor(constantMatcher) {
    this.constantMatcher = constantMatcher;
  }
  equals(left, right) {
    return left.name === right.name && this.constantMatcher.equals(left.value, right.value);
  }
};

// projects/moq/src/lib/expression.equality-comparers/index.ts
var expression_default3 = [
  { provide: ConstantEqualityComparer, useClass: ConstantEqualityComparer, deps: [ItEqualityComparer] },
  { provide: ArgumentsEqualityComparer, useClass: ArgumentsEqualityComparer, deps: [ConstantEqualityComparer] },
  { provide: GetPropertyEqualityComparer, useClass: GetPropertyEqualityComparer, deps: [] },
  { provide: InOperatorEqualityComparer, useClass: InOperatorEqualityComparer, deps: [] },
  {
    provide: InstanceMethodEqualityComparer,
    useClass: InstanceMethodEqualityComparer,
    deps: [ArgumentsEqualityComparer]
  },
  { provide: ItEqualityComparer, useClass: ItEqualityComparer, deps: [] },
  { provide: MethodEqualityComparer, useClass: MethodEqualityComparer, deps: [ArgumentsEqualityComparer] },
  { provide: NewOperatorEqualityComparer, useClass: NewOperatorEqualityComparer, deps: [ArgumentsEqualityComparer] },
  { provide: SetPropertyEqualityComparer, useClass: SetPropertyEqualityComparer, deps: [ConstantEqualityComparer] },
  {
    provide: ExpressionEqualityComparer,
    useClass: ExpressionEqualityComparer,
    deps: [
      GetPropertyEqualityComparer,
      SetPropertyEqualityComparer,
      MethodEqualityComparer,
      InstanceMethodEqualityComparer,
      InOperatorEqualityComparer,
      NewOperatorEqualityComparer,
      ItEqualityComparer
    ]
  }
];

// projects/moq/src/lib/injector/default-injector.config.ts
var DefaultInjectorConfig = class {
  constructor(providers = []) {
    this.providers = providers;
  }
  get(options, providers) {
    return [
      ...providers,
      ...mockOptionsProviders(options),
      ...tracker_default,
      ...reflector_default,
      ...presets_default,
      ...auto_mocking_default,
      ...verification_default,
      ...interceptors_default,
      ...playables_default,
      ...interaction_players_default,
      ...formatters_default,
      ...expression_default3,
      ...explorers_default,
      ...core_default,
      ...this.providers
    ];
  }
};

// projects/moq/src/lib/mock.ts
var _Mock = class {
  core;
  constructor(options = {}) {
    const preOptions = { ..._Mock.options, ...options };
    const providers = [
      { provide: MOCK, useValue: this, deps: [] },
      { provide: MOCK_CONSTRUCTOR, useValue: (opts) => new _Mock(opts), deps: [] }
    ];
    const injector = _Mock.InjectorFactory(preOptions, ...providers);
    this.core = injector.get(MockCore);
  }
  /**
   * @hidden
   * Returns a method that is internally used for creating of an angular based injector
   */
  static get injectionFactory() {
    return _Mock.InjectorFactory;
  }
  /**
   * @hidden
   * Sets a method that is internally used for creating of an angular based injector
   */
  static set injectionFactory(value) {
    _Mock.InjectorFactory = value;
  }
  /**
   * The default mock options that would applied to all instantiating Mock objects.
   * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
   * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
   * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
   */
  static get options() {
    if (_Mock.Options === void 0) {
      _Mock.Options = {
        target: () => void 0,
        injectorConfig: new DefaultInjectorConfig()
      };
    }
    return _Mock.Options;
  }
  /**
   * The default mock options that would applied to all instantiating Mock objects.
   * If an options are passed as constructor parameter they will override the default options.
   */
  static set options(options) {
    _Mock.Options = options;
  }
  get options() {
    return this.core.options;
  }
  get tracker() {
    return this.core.tracker;
  }
  get name() {
    return this.core.name;
  }
  setup(expression) {
    return this.core.setup(expression);
  }
  verify(expression, times = Times.Once()) {
    return this.core.verify(expression, times);
  }
  object() {
    return this.core.object();
  }
  prototypeof(prototype) {
    return this.core.prototypeof(prototype);
  }
  /**
   * @experimental
   */
  insequence(sequence, expression) {
    return this.core.insequence(sequence, expression);
  }
  resolve(token) {
    return this.core.resolve(token);
  }
};
var Mock = _Mock;
__publicField(Mock, "Options");
__publicField(Mock, "InjectorFactory", injectorFactory);

// projects/moq/src/lib/equal-matchers/common-type.provider.ts
var CommonTypeProvider = class {
  ofType(left, right) {
    return typeof right;
  }
};

// projects/moq/src/lib/equal-matchers/date.matcher.ts
var DateMatcher = class {
  matched(left, right) {
    if (left instanceof Date && right instanceof Date) {
      return left.valueOf() === right.valueOf();
    }
    return void 0;
  }
};

// projects/moq/src/lib/equal-matchers/equal-constant.matcher.ts
var EqualConstantMatcher = class {
  constructor(itEqualityComparer, equalMatcher) {
    this.itEqualityComparer = itEqualityComparer;
    this.equalMatcher = equalMatcher;
  }
  equals(left, right) {
    const actual = this.itEqualityComparer.equals(left, right);
    return actual === void 0 ? this.equalMatcher.matched(left, right) : actual;
  }
};

// projects/moq/src/lib/equal-matchers/equal.matcher.ts
var EqualMatcher = class {
  constructor(typesMatcher, commonTypeProvider, primitiveMatcher, objectMatcher, functionMatcher) {
    this.typesMatcher = typesMatcher;
    this.commonTypeProvider = commonTypeProvider;
    this.primitiveMatcher = primitiveMatcher;
    this.objectMatcher = objectMatcher;
    this.functionMatcher = functionMatcher;
  }
  matched(left, right) {
    if (this.typesMatcher.matched(left, right) === false) {
      return false;
    }
    switch (this.commonTypeProvider.ofType(left, right)) {
      case "undefined":
        return this.primitiveMatcher.matched(left, right);
      case "object":
        return this.objectMatcher.matched(left, right);
      case "boolean":
        return this.primitiveMatcher.matched(left, right);
      case "number":
        return this.primitiveMatcher.matched(left, right);
      case "string":
        return this.primitiveMatcher.matched(left, right);
      case "function":
        return this.functionMatcher.matched(left, right);
      case "symbol":
        return this.primitiveMatcher.matched(left, right);
      case "bigint":
        return this.primitiveMatcher.matched(left, right);
    }
  }
};

// projects/moq/src/lib/equal-matchers/function.matcher.ts
var FunctionMatcher = class {
  matched(left, right) {
    return left === right;
  }
};

// projects/moq/src/lib/equal-matchers/types.matcher.ts
var TypesMatcher = class {
  matched(left, right) {
    return typeof left === typeof right;
  }
};

// projects/moq/src/lib/equal-matchers/primitive.matcher.ts
var PrimitiveMatcher = class {
  matched(left, right) {
    return left === right;
  }
};

// projects/moq/src/lib/equal-matchers/object.matcher.ts
var ObjectMatcher = class {
  constructor(matchers) {
    this.matchers = matchers;
  }
  matched(left, right) {
    if (left === right)
      return true;
    if (left == null || right == null)
      return false;
    for (const matcher of this.matchers) {
      const matched = matcher.matched(left, right);
      if (matched === void 0) {
        continue;
      }
      return matched;
    }
    return false;
  }
};

// projects/moq/src/lib/equal-matchers/iterable.tester.ts
var IterableTester = class {
  verify(left, right) {
    return typeof left[Symbol.iterator] === "function" && typeof right[Symbol.iterator] === "function";
  }
};

// projects/moq/src/lib/equal-matchers/iterator.matcher.ts
var IteratorMatcher = class {
  constructor(injector, iterableTester) {
    this.injector = injector;
    this.iterableTester = iterableTester;
  }
  /*eslint-disable-next-line @typescript-eslint/ban-types*/
  matched(left, right) {
    if (this.iterableTester.verify(left, right) === true) {
      const leftIterator = [...left[Symbol.iterator]()];
      const rightIterator = [...right[Symbol.iterator]()];
      if (leftIterator.length !== rightIterator.length)
        return false;
      const constantMatcher = this.injector.get(ConstantEqualityComparer);
      for (let i = 0; i < leftIterator.length; i++) {
        const leftValue = leftIterator[i];
        const rightValue = rightIterator[i];
        if (constantMatcher.equals(leftValue, rightValue) === false) {
          return false;
        }
      }
      return true;
    }
    return void 0;
  }
};

// projects/moq/src/lib/equal-matchers/object-matchers.injection-token.ts
var OBJECT_MATCHERS = new InjectionToken("OBJECT_MATCHERS");

// projects/moq/src/lib/equal-matchers/pojo.matcher.ts
var POJOMatcher = class {
  constructor(mapMatcher, objectMapProvider) {
    this.mapMatcher = mapMatcher;
    this.objectMapProvider = objectMapProvider;
  }
  /*eslint-disable-next-line @typescript-eslint/ban-types*/
  matched(left, right) {
    const leftProps = this.objectMapProvider.get(left);
    const rightProps = this.objectMapProvider.get(right);
    return this.mapMatcher.matched(leftProps, rightProps);
  }
};

// projects/moq/src/lib/equal-matchers/object-map.provider.ts
var ObjectMapProvider = class {
  /*eslint-disable-next-line @typescript-eslint/ban-types*/
  get(object) {
    const props = this.getProps(object, []);
    const keys = [...new Set(props)];
    const map = /* @__PURE__ */ new Map();
    for (const key of keys) {
      map.set(key, object[key]);
    }
    return map;
  }
  getProps(object, props) {
    if (object === null)
      return props;
    if (object === Object.prototype)
      return props;
    props = [...props, ...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    return this.getProps(Object.getPrototypeOf(object), props);
  }
};

// projects/moq/src/lib/equal-matchers/map.matcher.ts
var MapMatcher = class {
  constructor(injector) {
    this.injector = injector;
  }
  matched(left, right) {
    if (left instanceof Map && right instanceof Map) {
      if (left.size !== right.size)
        return false;
      const constantMatcher = this.injector.get(ConstantEqualityComparer);
      for (const [key, value] of left) {
        if (right.has(key) === false)
          return false;
        if (constantMatcher.equals(value, right.get(key)) === false)
          return false;
      }
      return true;
    }
    return void 0;
  }
};

// projects/moq/src/lib/equal-matchers/index.ts
var equal_matchers_default = [
  { provide: ConstantEqualityComparer, useExisting: EqualConstantMatcher },
  { provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [ItEqualityComparer, EqualMatcher] },
  { provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: [] },
  {
    provide: EqualMatcher,
    useClass: EqualMatcher,
    deps: [
      TypesMatcher,
      CommonTypeProvider,
      PrimitiveMatcher,
      ObjectMatcher,
      FunctionMatcher
    ]
  },
  { provide: FunctionMatcher, useClass: FunctionMatcher, deps: [] },
  { provide: IterableTester, useClass: IterableTester, deps: [] },
  {
    provide: IteratorMatcher,
    useClass: IteratorMatcher,
    deps: [
      Injector,
      IterableTester
    ]
  },
  { provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS] },
  { provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider] },
  { provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: [] },
  { provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: [] },
  { provide: TypesMatcher, useClass: TypesMatcher, deps: [] },
  { provide: MapMatcher, useClass: MapMatcher, deps: [Injector] }
];

// projects/moq/src/lib/injector/equal-matching-injector.config.ts
var EqualMatchingInjectorConfig = class extends DefaultInjectorConfig {
  constructor(matchers = [], providers = []) {
    super(providers);
    this.matchers = matchers;
  }
  get(options, providers) {
    return [
      ...super.get(options, providers),
      ...equal_matchers_default,
      ...this.matchers,
      { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
      { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
      { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
      { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] }
    ];
  }
};

// projects/moq/src/lib/presets/factories/mimics-rejected-async-preset.factory.ts
var MimicsRejectedAsyncPresetFactory = class {
  constructor(rootMock, presets, rejectedPromise) {
    this.rootMock = rootMock;
    this.presets = presets;
    this.rejectedPromise = rejectedPromise;
    return this.factory();
  }
  factory() {
    return (target, playable, value) => {
      const preset = new MimicsPreset(playable, target, this.rejectedPromise(value));
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/presets/factories/mimics-resolved-async-preset.factory.ts
var MimicsResolvedAsyncPresetFactory = class {
  constructor(rootMock, presets, resolvedPromise) {
    this.rootMock = rootMock;
    this.presets = presets;
    this.resolvedPromise = resolvedPromise;
    return this.factory();
  }
  factory() {
    return (target, playable, value) => {
      const preset = new MimicsPreset(playable, target, this.resolvedPromise(value));
      this.presets.add(preset);
      return this.rootMock;
    };
  }
};

// projects/moq/src/lib/reflector/method-reflecting-proxy.factory.ts
var MethodReflectingProxyFactory = class {
  constructor(injector) {
    this.injector = injector;
  }
  create() {
    const apply = this.injector.get(MethodReflectorTrap);
    const options = { apply };
    const reflector = function() {
      return void 0;
    };
    return new Proxy(reflector, options);
  }
};

// projects/moq/src/lib/static.injector/type.ts
var Type = Function;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  APPLY_RETURN_VALUE,
  ApplyReflectorTrap,
  ApplyTrap,
  ArgumentsEqualityComparer,
  AsyncExpressionDetector,
  AsyncExpressionReflector,
  AsyncReflectingProxyInjectorFactory,
  AutoMockFactory,
  AutoMockInjectorConfig,
  AutoMockNameFormatter,
  AutoMockOptionsBuilder,
  AutoMockProvider,
  AutoMockedStorage,
  CONSTRUCT_RETURN_VALUE,
  CallCounter,
  CallbackPresetFactory,
  CallbackPresetPlayer,
  CallbacksPreset,
  CommonTypeProvider,
  ComplexExpressionErrorFormatter,
  ComplexExpressionGuard,
  ComplexExpressionValidator,
  CompositeExpressionReflector,
  ConstantEqualityComparer,
  ConstantFormatter,
  ConstructReflectorTrap,
  ConstructTrap,
  DateMatcher,
  DefaultInjectorConfig,
  EXPRESSIONS,
  EXPRESSION_REFLECTOR,
  EqualConstantMatcher,
  EqualMatcher,
  EqualMatchingInjectorConfig,
  Expression,
  ExpressionEqualityComparer,
  ExpressionFormatter,
  ExpressionGuardExceptionFactory,
  ExpressionHasMethodExplorer,
  ExpressionHasPropertyExplorer,
  ExpressionValidator,
  ExpressionsFormatter,
  FunctionExpression,
  FunctionExpressionValidator,
  FunctionFormatter,
  FunctionMatcher,
  GET_RETURN_VALUE,
  GetPropertyEqualityComparer,
  GetPropertyExpression,
  GetPropertyExpressionValidator,
  GetPropertyFormatter,
  GetPrototypeOfTrap,
  GetReflectorTrap,
  GetTrap,
  HasMethodExplorer,
  HasPropertyExplorer,
  HasReflectorTrap,
  HasTrap,
  Host,
  INJECTOR,
  INJECTOR_IMPL,
  InOperatorEqualityComparer,
  InOperatorExpression,
  InOperatorExpressionValidator,
  InOperatorFormatter,
  InOperatorInteractionExplorer,
  InjectFlags,
  InjectionToken,
  Injector,
  InstanceMethodEqualityComparer,
  InstanceMethodExpressionValidator,
  InteractionFormatter,
  InteractionPlayer,
  It,
  ItEqualityComparer,
  IterableTester,
  IteratorMatcher,
  MOCK,
  MOCK_CONSTRUCTOR,
  MOCK_OPTIONS,
  MapMatcher,
  MembersMethodExplorer,
  MembersPropertyExplorer,
  MethodEqualityComparer,
  MethodExpression,
  MethodFormatter,
  MethodOnlyReflectingProxyFactory,
  MethodReflectingProxyFactory,
  MethodReflectorTrap,
  MimicsPreset,
  MimicsPresetFactory,
  MimicsPresetPlayer,
  MimicsRejectedAsyncPresetFactory,
  MimicsResolvedAsyncPresetFactory,
  Mock,
  MockCore,
  MockOptionsBuilder,
  MoqAPI,
  NG_TEMP_TOKEN_PATH,
  NO_NEW_LINE,
  NamePrefixProvider,
  NewOperatorEqualityComparer,
  NewOperatorExpression,
  NewOperatorExpressionValidator,
  NewOperatorFormatter,
  NullInjector,
  OBJECT_MATCHERS,
  ObjectHasMethodExplorer,
  ObjectHasPropertyExplorer,
  ObjectMapProvider,
  ObjectMatcher,
  Optional,
  POJOMatcher,
  PlayTimes,
  PlayableAlways,
  PlayableExactly,
  PlayableNever,
  PlayableOnce,
  PlayablePresetProvider,
  PlayableSequence,
  PlayableUpdateReason,
  PresetBuilder,
  PresetBuilderFactory,
  PresetHasInOperatorExplorer,
  PresetHasMethodExplorer,
  PresetHasPropertyExplorer,
  PresetPlayablesUpdater,
  PresetPlayer,
  Presets,
  PrimitiveMatcher,
  PropertiesValueStorage,
  PropertyDescriptorProvider,
  PropertyIsReadOnlyTester,
  PropertyKeyFormatter,
  PrototypeStorage,
  ProxyFactory,
  REFLECT_APPLY,
  REFLECT_HAS,
  ROOT_MOCK,
  Range,
  ReflectingProxyFactory,
  ReflectingProxyInjectorFactory,
  RejectedPromiseFactory,
  ResolvedPromiseFactory,
  ReturnsAsyncPresetFactory,
  ReturnsPreset,
  ReturnsPresetFactory,
  RootMockProvider,
  SOURCE,
  Self,
  SequenceId,
  SetPropertyEqualityComparer,
  SetPropertyExpression,
  SetPropertyExpressionValidator,
  SetPropertyFormatter,
  SetPrototypeOfTrap,
  SetReflectorTrap,
  SetTrap,
  SetupFactory,
  SkipSelf,
  SpyFunctionProvider,
  StaticInjector,
  StringErrorStyler,
  SyncExpressionReflector,
  THROW_IF_NOT_FOUND,
  ThrowsAsyncPresetFactory,
  ThrowsPreset,
  ThrowsPresetFactory,
  Times,
  TrackedExpressionsFormatter,
  Tracker,
  Type,
  TypesMatcher,
  USE_VALUE,
  VerificationTester,
  Verifier,
  VerifyError,
  VerifyFormatter,
  catchInjectorError,
  dump,
  formatError,
  forwardRef,
  getClosureSafeProperty,
  injectorFactory,
  isForwardRef,
  mockOptionsProviders,
  resolveForwardRef,
  stringify
});
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
