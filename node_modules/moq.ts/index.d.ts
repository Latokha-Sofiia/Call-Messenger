/**
 * Sets the rules where bounds of a range are included or excluded from the range.
 * See {@link Times.Between}
 */
declare enum Range {
    Exclusive = 0,
    Inclusive = 1
}
/**
 * This class expresses the expectation about amount of invocations.
 *
 * @example
 * ```typescript
 *
 * const times = new Times(expected => expected === 1, `Should be called once`);
 * const actual = times.test(2);
 *
 * expect(actual).toBe(false);
 * expect(times.message).toBe(`Should be called once`);
 * ```
 *
 * ```typescript
 *
 * const mockName = 'mock name';
 *const mock = new Mock<ITestObject>(mockName);
 *const object = mock.object();
 *
 *object.property;
 *
 *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
 *
 *expect(action).toThrow();
 * ```
 */
declare class Times {
    private evaluator;
    message: string;
    private static _once;
    private static _never;
    private static _atMostOnce;
    private static _atLeastOnce;
    /**
     *
     * @param evaluator It takes actual value and decides if it is expected or not.
     * Returns true or false accordingly.
     * @param message A message that describes the expectation.
     */
    constructor(evaluator: (callCount: number) => boolean, message: string);
    /**
     * It expects that the actual would be equal or bigger then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtLeast(callCount: number): Times;
    /**
     * It expects that the actual would be equal or bigger then 1.
     */
    static AtLeastOnce(): Times;
    /**
     * It expects that the actual would be equal or smaller then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtMost(callCount: number): Times;
    /**
     * It expects that the actual would be equal or less then 1.
     */
    static AtMostOnce(): Times;
    /**
     * It expects that the actual would be in the expected range of values.
     *
     * @param callCountFrom The lowest bound of the range.
     * @param callCountTo The highest bound of the range.
     * @param range  Sets the rules where bounds of a range are included or excluded from the range.
     */
    static Between(callCountFrom: number, callCountTo: number, range: Range): Times;
    /**
     * It expects that the actual is equal to the expected value.
     *
     * @param callCount The expected value.
     */
    static Exactly(callCount: number): Times;
    /**
     * It expects that the actual is equal 0.
     */
    static Never(): Times;
    /**
     * It expects that the actual is equal 1.
     */
    static Once(): Times;
    /**
     * Evaluates the expectation against the actual value.
     *
     * @param callCount The actual value.
     */
    test(callCount: number): boolean;
}

declare type IPredicate<T> = (instance: T) => boolean;
/**
 * This class allows to express wide range of cases in an expression.
 * You can use it with setups or verifies methods.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
 *  .returns(value)
 *  .setup(instance => instance(It.IsAny())
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 *
 * This class could be used not only for args matching, but also for function names, property names and so on.
 *
 * @example
 * ```typescript
 *
 * const object = new Mock<ITestObject>()
 * // the expression dynamically checks the property name that is being read
 * .setup(instance => It.Is((expression: GetPropertyExpression) => expression.name === 'property'))
 * .returns(value)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * //denis any write operation on the property
 * .setup(instance => { instance.property = It.IsAny()})
 * // true - allow, false - deny
 * .returns(false)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * .setup(instance => It.Is((expression: NamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
 * .returns(value)
 * .object();
 *
 * // how to use with verify
 * mock.verify(instance => instance.method(It.Is(a => a === 2)));
 * ```
 */
declare class It<P> {
    readonly predicate: IPredicate<P>;
    constructor(predicate: IPredicate<P>);
    /**
     * This factory method returns an expression that matches custom cases.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static Is<T>(predicate: IPredicate<T>): It<T> | any;
    /**
     * This factory method returns a wildcat expression that matches any value.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(any_value_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static IsAny<T>(): It<T> | any;
    private static readonly isAnyPredicate;
    /**
     * Exams if the instance matches the predicate.
     */
    test(instance?: P): boolean;
}

declare abstract class Expression {
    readonly name: PropertyKey;
    readonly args: any[];
    protected constructor(name: PropertyKey, args: any[]);
}
/**
 * This class represents an invocation of an instance method.
 * It provides access to the name of it and the parameters.
 */
declare class MethodExpression extends Expression {
    constructor(name: PropertyKey, args: any[]);
}
/**
 * This class represents an invocation of a function.
 * It provides access to the parameters.
 */
declare class FunctionExpression extends Expression {
    constructor(args: any[]);
}
/**
 * This class represents a property accessing.
 * It provides access to the name of property.
 */
declare class GetPropertyExpression extends Expression {
    constructor(name: PropertyKey);
}
/**
 * This class represents a property write interaction.
 * It provides access to the name of property and the value.
 */
declare class SetPropertyExpression extends Expression {
    readonly value: any;
    constructor(name: PropertyKey, value: any);
}
/**
 * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
 * It provides access to the name of property.
 */
declare class InOperatorExpression extends Expression {
    constructor(name: PropertyKey);
}
/**
 * This class represents applying of [new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).
 * It provides access to the arguments of the constructor.
 */
declare class NewOperatorExpression extends Expression {
    constructor(args: any[]);
}
/**
 * Union of the expressions and It type.
 */
declare type Expressions<T> = FunctionExpression | GetPropertyExpression | SetPropertyExpression | InOperatorExpression | MethodExpression | NewOperatorExpression | It<T>;

/**
 * @hidden
 */
declare class SequenceId {
    private value;
    next(): number;
}

/**
 * This class represents a recorded interaction with the a mocked object.
 */
interface TrackedAction {
    id: number;
    expression: Expression;
}
/**
 * This class records all interactions with a mocked object.
 */
declare class Tracker {
    private sequenceId;
    private log;
    constructor(sequenceId: SequenceId);
    /**
     * @hidden
     */
    add(action: Expression): void;
    /**
     * Returns recorded interactions.
     */
    get(): TrackedAction[];
    interactions(): Expression[];
}

/**
 * @description
 *
 * Represents an abstract class `T`, if applied to a concrete class it would stop being
 * instantiatable.
 *
 * @publicApi
 */
interface AbstractType<T> extends Function {
    prototype: T;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Represents a type that a Component or other object is instances of.
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @publicApi
 */
declare const Type: FunctionConstructor;
declare type Type<T> = new (...args: any[]) => T;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Configures the `Injector` to return a value for a token.
 * Base for `ValueProvider` decorator.
 *
 * @publicApi
 */
interface ValueSansProvider {
    /**
     * The value to inject.
     */
    useValue: any;
}
/**
 * Configures the `Injector` to return a value for a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ValueProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ValueProvider extends ValueSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return an instance of `useClass` for a token.
 * Base for `StaticClassProvider` decorator.
 *
 * @publicApi
 */
interface StaticClassSansProvider {
    /**
     * An optional class to instantiate for the `token`. By default, the `provide`
     * class is instantiated.
     */
    useClass: Type<any>;
    /**
     * A list of `token`s to be resolved by the injector. The list of values is then
     * used as arguments to the `useClass` constructor.
     */
    deps: any[];
}
/**
 * Configures the `Injector` to return an instance of `useClass` for a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}
 *
 * Note that following two providers are not equal:
 *
 * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface StaticClassProvider extends StaticClassSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return an instance of a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * ```ts
 * @Injectable(SomeModule, {deps: []})
 * class MyService {}
 * ```
 *
 * @publicApi
 */
interface ConstructorSansProvider {
    /**
     * A list of `token`s to be resolved by the injector.
     */
    deps?: any[];
}
/**
 * Configures the `Injector` to return an instance of a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ConstructorProvider extends ConstructorSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: Type<any>;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return a value of another `useExisting` token.
 *
 * @see `ExistingProvider`
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @publicApi
 */
interface ExistingSansProvider {
    /**
     * Existing `token` to return. (Equivalent to `injector.get(useExisting)`)
     */
    useExisting: any;
}
/**
 * Configures the `Injector` to return a value of another `useExisting` token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ExistingProvider extends ExistingSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return a value by invoking a `useFactory` function.
 *
 * @see `FactoryProvider`
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @publicApi
 */
interface FactorySansProvider {
    /**
     * A function to invoke to create a value for this `token`. The function is invoked with
     * resolved values of `token`s in the `deps` field.
     */
    useFactory: Function;
    /**
     * A list of `token`s to be resolved by the injector. The list of values is then
     * used as arguments to the `useFactory` function.
     */
    deps?: any[];
}
/**
 * Configures the `Injector` to return a value by invoking a `useFactory` function.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}
 *
 * Dependencies can also be marked as optional:
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface FactoryProvider extends FactorySansProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Describes how an `Injector` should be configured as static (that is, without reflection).
 * A static provider provides tokens to an injector for various types of dependencies.
 *
 * @see [Injector.create()](/api/core/Injector#create).
 * @see ["Dependency Injection Guide"](guide/dependency-injection-providers).
 *
 * @publicApi
 */
declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];

interface InjectionFactory {
    factory(...args: unknown[]): unknown;
}
declare type TypeOfInjectionFactory<T extends InjectionFactory> = ReturnType<T["factory"]>;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
declare class InjectionToken<T> {
    protected desc: string;
    constructor(desc: string);
    toString(): string;
}

/**
 * A function that accepts a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
 * and either plays expected interaction or returns a predicate function.
 * See {@link IMock.setup} function and {@link It} class for more details.
 */
declare type IExpression<T> = (instance: T) => void | any | It<T>;
/**
 * This class reflects an expression to an expression tree representation.
 */
interface ExpressionReflector {
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect<T>(expression: IExpression<T>): Expressions<T>[];
}
/**
 * Injection token for an expression reflector
 */
declare const EXPRESSION_REFLECTOR: InjectionToken<ExpressionReflector>;
/**
 * @hidden
 */
declare const EXPRESSIONS: InjectionToken<Expressions<unknown>[]>;
/**
 * @hidden
 */
interface IReturnValueFactory {
    create(): any;
}
/**
 * @hidden
 */
declare const GET_RETURN_VALUE: InjectionToken<IReturnValueFactory>;
/**
 * @hidden
 */
declare const APPLY_RETURN_VALUE: InjectionToken<IReturnValueFactory>;
/**
 * @hidden
 */
declare const CONSTRUCT_RETURN_VALUE: InjectionToken<IReturnValueFactory>;

declare type PromisedType<T> = T extends Promise<infer P> ? P : never;
declare const enum PlayableUpdateReason {
    /**
     * The playable is update because it's setup is about to be played
     */
    OwnSetupWouldBePlayed = 0,
    /**
     * The playable is update because another setup is about to be played
     */
    OtherSetupWouldBePlayed = 1
}
/**
 * Provides playable logic for a setup
 */
interface IPlayable {
    /**
     * Tests if setup is playable
     */
    isPlayable(): boolean;
    /**
     * Invokes as the setup is about to be played, so the playable logic can change it's state.
     *
     * @param reason The reason why this update is called {@link PlayableUpdateReason}
     * @example
     * ```typescript
     *
     *     const playable1 = new PlayableOnce();
     *     const playable2 = new PlayableOnce();
     *
     *     const mock = new Mock<(val: number) => void)>()
     *     // setup A
     *     .setup(instance => instance(1))
     *     .play(playable1)
     *     .returns(1)
     *     // setup B
     *     .setup(instance => instance(2))
     *     .play(playable2)
     *     .returns(2);
     *
     *     const actual = mock.object()(1);
     *     // at this point the update of playable1 should be called with OwnSetupWouldBePlayed
     *     // because setup A would be played
     *     // and the update of playable2 should be called with OtherSetupWouldBePlayed
     * ```
     */
    update(reason: PlayableUpdateReason): void;
}
/**
 * Sets a behaviour rule for a particular use case
 *
 * @param T The type of mocked object.
 */
interface IPresetBuilder<T, TValue = any> {
    /**
     * Returns the provided value as a result of interaction in case of
     * - get property value
     * - invocation a function
     *
     * Controls write operation in case of
     * - property assignment (true - the assignment is allowed, false - the assignment is not allowed)
     *
     * @param value The value
     */
    returns(value: TValue): IMock<T>;
    /**
     * Returns the provided value with a resolved Promise as a result of invocation an asynchronous function
     *
     * @param value The value
     */
    returnsAsync(value: PromisedType<TValue>): IMock<T>;
    /**
     * Throws the provided exception.
     */
    throws<TException>(exception: TException): IMock<T>;
    /**
     * Returns the provided value with a rejected Promise as a result of interaction with an asynchronous function.
     */
    throwsAsync<TException>(exception: TException): IMock<T>;
    /**
     * @param callback A callback function that will intercept the interaction.
     * The function may returns a value that will be provided as result (see {@link IPresetBuilder.returns})
     * @example
     * ```typescript
     *
     *     const ipcRendererMock = new StrictMock<typeof ipcRenderer>()
     *     .setup(instance => instance.on(ipcRendererChannelName, It.IsAny()))
     *     .callback(({args: [channel, listener]}) => listener(undefined, response));
     * ```
     */
    callback(callback: (interaction: Expression) => TValue): IMock<T>;
    /**
     * Plays the setup on target invocation when predicate returns true otherwise the setup will be ignored.
     * As predicate {@link PlayTimes} could be used.
     */
    play(predicate: IPlayable): IPresetBuilder<T, TValue>;
    /**
     * Replicates interactions with original object.
     * The mock object keeps tracking all interactions and reflects them on the original object.
     *
     * @example
     * ```typescript
     *
     * const value = 2;
     *
     * class Origin {
     *   public property = value;
     *}
     *
     * const origin = new Origin();
     * const mock = new Mock<Origin>()
     * .setup(() => It.IsAny())
     * .mimics(origin);
     *
     * const actual = mock.object().property;
     * expect(actual).toBe(2);
     * ```
     */
    mimics(origin: T): IMock<T>;
}
/**
 * The main API of the framework.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 * ---
 * #### Latest setups have more precedence over earlier setups.
 * @example
 * ```typescript
 *
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(1)
 *  .setup(instance => instance(1))
 *  .returns(2)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(2);
 * ```
 *
 * @param T The type of mocked object. Could be any type including:
 * - Function,
 * - arrow function,
 * - interface,
 * - class,
 * - object and etc.
 */
interface IMock<T> {
    /**
     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct
     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].
     */
    readonly name?: string;
    /**
     * Returns the tracker object that responsible for storing history of interactions with the mocked object.
     */
    readonly tracker: Tracker;
    /**
     * Returns options object
     */
    readonly options: IMockOptions<T>;
    /**
     * Returns instance of mocked object
     */
    object(): T;
    /**
     * Defines a configuration for particular interaction with the mocked object.
     *
     * @example
     * ```typescript
     *
     * // a function invoke with 1 as parameter
     * .setup(instance => instance(1))
     *
     * // apply function invoke on a function with null as the first parameter and a placeholder for the second parameter
     * .setup(instance => instance.apply(null, It.IsAny()))
     *
     * // accessing to a property
     * .setup(instance => instance.property)
     *
     * //accessing to a named function with name 'test' of an object and the first parameter is 1
     * .setup(instance => It.Is((expression: NamedMethodExpression) => {
     *      return expression.name === 'test' && expression.args[0] === 1
     * }))
     *
     * //setting propertyA to value of 'a'
     * .setup(instance => {instance.propertyA = 'a'})
     * ```
     * @param expression A function that accepts a
     * [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
     * and either plays expected interaction or returns a predicate function.
     * Refer {@link It} class for parameter placeholders or predicate functions.
     * Refer the integration tests for more examples.
     * @returns PresetBuilder config interface for the provided expression.
     */
    setup<E extends IExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    /**
     * Asserts expected interactions with the mocked object.
     *
     * @param expression Expected expression
     * @param times The default value is {@link Times.Once()}
     */
    verify(expression: IExpression<T>, times?: Times): IMock<T>;
    /**
     * Set the prototype of the mocked object.
     *
     * @example
     * ```typescript
     *
     *  class PrototypeClass {}
     *
     *  const mock = new Mock<{}>();
     *  const object = mock.object();
     *
     *  Object.setPrototypeOf(object, PrototypeClass.prototype);
     *
     *  expect(object instanceof PrototypeClass).toBe(true);
     * ```
     */
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     * @hidden
     */
    insequence(sequence: ISequenceVerifier, expression: IExpression<T>): IMock<T>;
    /**
     * Retrieves an instance from the injector based on the provided token.
     *
     * @returns The instance from the injector if defined, otherwise null.
     */
    resolve<S, R = S extends InjectionFactory ? TypeOfInjectionFactory<S> : S>(token: Type<S> | InjectionToken<S>): R;
}
/**
 * @hidden
 * @experimental
 */
interface ISequenceVerifier {
    add<T>(mock: IMock<T>, expression: IExpression<T>): ISequenceVerifier;
    verify(times?: Times): void;
}
/**
 * A mock object exposes a symbol property to access to its Moq API.
 * This property is read only and trackable.
 * Since this property makes sense only in context of the moq library
 * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.
 *
 * @example
 * ```typescript
 *
 *  const mock = new Mock<() => void>()
 *  .object();
 *
 *  mock[MoqAPI]
 *  .setup(instance => instance())
 *  .returns(12);
 *
 *  const actual = mock();
 *
 *  expect(actual).toBe(12);
 * ```
 */
declare const MoqAPI: unique symbol;
/**
 * The Mock internally depends on angular based injector to construct its dependencies.
 */
interface IInjectorConfig {
    /**
     * Returns array of StaticProviders to construct an angular based injector.
     *
     * @param options The final version of mock options. Options that passed to Mock constructor are merged with
     * the global mock options ({@link Mock.options}). Some components depend on the options and the injector
     * should be able to resolve it. To configure the injector property the implementation could do the following:
     * ``` typescript
     * return [
     *  {provide: MOCK_OPTIONS, useValue: options, deps: []},
     * ];
     * ```
     * @param providers An array of additional providers that could be added to the final configuration.
     */
    get(options: IMockOptions<unknown>, ...providers: StaticProvider[]): StaticProvider[];
}
/**
 * Mock instance options.
 * Could be passed as parameter on mock instantiating or could be set globally on {@link Mock.options}.
 */
interface IMockOptions<T> {
    /**
     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct
     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].
     */
    name?: string;
    /**
     * The target object for Proxy that is used under the hood.
     * typeof operation is applied to this target.
     * The default value is a function.
     */
    target?: T;
    /**
     * The Mock internally based on angular injector to construct its dependencies.
     * An instance of {@link IInjectorConfig} implementation could be passed as parameter in order to
     * changed the mock behaviour. The default value is an instance of {@link DefaultInjectorConfig}.
     * There is also {@link EqualMatchingInjectorConfig} that would setup Mock to use equal logic for comparing values.
     */
    injectorConfig?: IInjectorConfig;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
 *
 * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
 * project.
 *
 * @publicApi
 */
declare const INJECTOR: InjectionToken<Injector>;
declare class NullInjector implements Injector {
    get(token: any, notFoundValue?: any): any;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection flags for DI.
 *
 * @publicApi
 */
declare enum InjectFlags {
    /** Check self and check parent injector if needed */
    Default = 0,
    /**
     * Specifies that an injector should retrieve a dependency from any injector until reaching the
     * host element of the current component. (Only used with Element Injector)
     */
    Host = 1,
    /** Don't ascend to ancestors of the node requesting injection. */
    Self = 2,
    /** Skip the node that is requesting injection. */
    SkipSelf = 4,
    /** Inject `defaultValue` instead if token not found. */
    Optional = 8
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Concrete injectors implement this interface. Injectors are configured
 * with [providers](guide/glossary#provider) that associate
 * dependencies of various types with [injection tokens](guide/glossary#di-token).
 *
 * @see ["DI Providers"](guide/dependency-injection-providers).
 * @see `StaticProvider`
 *
 * @usageNotes
 *
 *  The following example creates a service injector instance.
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Usage example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @publicApi
 */
declare abstract class Injector {
    static THROW_IF_NOT_FOUND: {};
    static NULL: Injector;
    /**
     * @internal
     * @nocollapse
     */
    static __NG_ELEMENT_ID__: number;
    /**
     * Creates a new injector instance that provides one or more dependencies,
     * according to a given type or types of `StaticProvider`.
     *
     * @param options An object with the following properties:
     * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).
     * * `parent`: (optional) A parent injector.
     * * `name`: (optional) A developer-defined identifying name for the new injector.
     *
     * @returns The new injector instance.
     *
     */
    static create(options: {
        providers: StaticProvider[];
        parent?: Injector;
        name?: string;
    }): Injector;
    /**
     * Retrieves an instance from the injector based on the provided token.
     *
     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.
     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.
     */
    abstract get<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;
}

/**
 * Creates an angular based injector
 */
declare function injectorFactory<T>(options: IMockOptions<T>, ...providers: StaticProvider[]): Injector;

/**
 * The default implementation of {@link IMock} interface.
 */
declare class Mock<T> implements IMock<T> {
    private static Options;
    private static InjectorFactory;
    private readonly core;
    constructor(options?: IMockOptions<T>);
    /**
     * @hidden
     * Returns a method that is internally used for creating of an angular based injector
     */
    static get injectionFactory(): typeof injectorFactory;
    /**
     * @hidden
     * Sets a method that is internally used for creating of an angular based injector
     */
    static set injectionFactory(value: typeof injectorFactory);
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
     * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
     * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
     */
    static get options(): IMockOptions<unknown>;
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * If an options are passed as constructor parameter they will override the default options.
     */
    static set options(options: IMockOptions<unknown>);
    get options(): IMockOptions<any>;
    get tracker(): Tracker;
    get name(): string;
    setup<E extends IExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    verify(expression: IExpression<T>, times?: Times): IMock<T>;
    object(): T;
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     */
    insequence(sequence: ISequenceVerifier, expression: IExpression<T>): IMock<T>;
    resolve<S, R = S extends InjectionFactory ? TypeOfInjectionFactory<S> : S>(token: Type<S> | InjectionToken<S>): R;
}

/**
 * This function dumps into console.log all interactions with the mocked object
 */
declare function dump<T>(mock: IMock<T>, writer?: Console): void;

declare class ReflectingProxyInjectorFactory {
    create(options?: {
        providers: StaticProvider[];
    }): Injector;
}

/**
 * This class reflects an expression to an expression tree representation.
 * async/await is not supported.
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
 */
declare class SyncExpressionReflector implements ExpressionReflector {
    private readonly injectorFactory;
    constructor(injectorFactory: ReflectingProxyInjectorFactory);
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect<T>(expression: IExpression<T>): Expressions<T>[];
    reflectAsync<T>(expression: IExpression<T>): Promise<Expressions<T>[]>;
}

declare class AsyncExpressionDetector {
    isAsync<T>(expression: IExpression<T>): boolean;
}

declare class AsyncReflectingProxyInjectorFactory {
    private readonly reflectingProxyInjectorFactory;
    constructor(reflectingProxyInjectorFactory: ReflectingProxyInjectorFactory);
    create(options?: {
        providers: StaticProvider[];
    }): Injector;
}

/**
 * This class reflects an async expression to an expression tree representation.
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/async.expression-reflector.spec.ts)
 */
declare class AsyncExpressionReflector implements ExpressionReflector {
    private readonly injectorFactory;
    constructor(injectorFactory: AsyncReflectingProxyInjectorFactory);
    /**
     * Reflects the provided async code as an expression tree.
     */
    reflect<T>(expression: IExpression<T>): Expressions<T>[];
}

/**
 * This class reflects an expression to an expression tree representation.
 * async/await expressions are reflected in shellow mode.
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
 */
declare class CompositeExpressionReflector implements ExpressionReflector {
    private readonly asyncExpressionDetector;
    private readonly syncExpressionReflector;
    private readonly asyncExpressionReflector;
    constructor(asyncExpressionDetector: AsyncExpressionDetector, syncExpressionReflector: SyncExpressionReflector, asyncExpressionReflector: AsyncExpressionReflector);
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect<T>(expression: IExpression<T>): Expressions<T>[];
}

/**
 * This class sets rules when a configured setup should be applied to the target invocation or not.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Once())
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
declare class PlayTimes {
    private static readonly always;
    private static readonly never;
    /**
     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
     */
    static Exactly(count: number): IPlayable;
    /**
     * The configured setup will be always applied to invocations.
     */
    static Always(): IPlayable;
    /**
     * The configured setup will be never applied to invocations.
     */
    static Never(): IPlayable;
    /**
     * The configured setup will be applied only to the first invocation.
     */
    static Once(): IPlayable;
    /**
     * The configured setup will be applied or not accordingly to the value in the sequence.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Sequence([false, true]))
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(undefined);
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    static Sequence(sequence: boolean[]): IPlayable;
}

/**
 * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
 */
declare class PlayableExactly implements IPlayable {
    private count;
    private invoked;
    constructor(count: number);
    readonly update: (reason: PlayableUpdateReason) => void;
    readonly isPlayable: () => boolean;
}

/**
 * The configured setup will be applied only to the first invocation.
 */
declare class PlayableOnce implements IPlayable {
    private played;
    readonly update: (reason: PlayableUpdateReason) => void;
    readonly isPlayable: () => boolean;
}

/**
 * The configured setup will be never applied to invocations.
 */
declare class PlayableNever implements IPlayable {
    readonly update: () => any;
    readonly isPlayable: () => boolean;
}

/**
 * The configured setup will be always applied to invocations.
 */
declare class PlayableAlways implements IPlayable {
    readonly isPlayable: () => boolean;
    readonly update: () => any;
}

/**
 * The configured setup will be applied or not accordingly to the value in the sequence.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Sequence([false, true]))
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(undefined);
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
declare class PlayableSequence implements IPlayable {
    private sequence;
    private index;
    constructor(sequence: boolean[]);
    readonly update: () => void;
    readonly isPlayable: () => boolean;
}

/**
 * Provides the default configuration for an angular based injector that would be used internally by {@link Mock} instance.
 */
declare class DefaultInjectorConfig implements IInjectorConfig {
    private readonly providers;
    constructor(providers?: StaticProvider[]);
    get(options: IMockOptions<unknown>, providers: StaticProvider[]): StaticProvider[];
}

/**
 * Provides the configuration for Angular based injector that would use equal logic for matching values.
 * By default, all values are matched with
 * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
 * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
 * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
 * and introduce deep equal comparison logic as well as an extension point for custom matchers.
 *
 * ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>()
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
 *  expect(actual).toBe(undefined);
 *  ```
 *  and compare with
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  expect(actual).toBe(2);
 *  ```
 *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
 *
 *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
 *  then more general matchers would be invoked.
 *
 *  The library comes with the following matchers:
 *  0. Custom matchers
 *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
 *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
 *  3. IteratorMatcher - matches objects that supports
 *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
 *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
 *
 *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *     matched<T extends object>(left: T, right: T): boolean | undefined {
 *         if (left instanceof Date && isMoment(right)) {
 *             return left.valueOf() === right.valueOf();
 *         }
 *         return undefined;
 *     }
 * }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *     provide: OBJECT_MATCHERS,
 *     useClass: MomentDateMatcher,
 *     multi: true,
 *     deps: []
 * }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
 *  So you can do a partial comparision.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
 *
 *  const func = () => undefined;
 *
 *  const injectorConfig = new EqualMatchingInjectorConfig();
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object({func});
 *
 *  expect(actual).toBe(2);
 *  ```
 */
declare class EqualMatchingInjectorConfig extends DefaultInjectorConfig {
    private matchers;
    constructor(matchers?: StaticProvider[], providers?: StaticProvider[]);
    get(options: IMockOptions<unknown>, providers: StaticProvider[]): StaticProvider[];
}

/**
 * @Hidden
 */
declare const MOCK: InjectionToken<IMock<unknown>>;

/**
 * @hidden
 */
declare const MOCK_OPTIONS: InjectionToken<IMockOptions<any>>;

/**
 *  A custom matcher should implement this interface and be registered with EqualMatchingInjectorConfig.
 *  The parameters are always are not null or undefined and they are always not equal (!==).
 *
 *  @return undefined if the matcher is not intended to compare objects of such type, otherwise result of comparision.
 *
 *  ``` typescript
 *  // A custom matcher that matches Moment and Date objects
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *      matched<T extends object>(left: T, right: T): boolean | undefined {
 *          if (left instanceof Date && isMoment(right)) {
 *              return left.valueOf() === right.valueOf();
 *          }
 *          return undefined;
 *      }
 *  }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *      provide: OBJECT_MATCHERS,
 *      useClass: MomentDateMatcher,
 *      multi: true,
 *      deps: []
 *  }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 */
interface IObjectMatcher {
    matched<T extends object>(left: T, right: T): boolean | undefined;
}

declare const OBJECT_MATCHERS: InjectionToken<IObjectMatcher[]>;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type of the Optional metadata.
 */
declare class Optional {
}
/**
 * Type of the Self metadata.
 */
declare class Self {
}
/**
 * Type of the SkipSelf metadata.
 */
declare class SkipSelf {
}
/**
 * Type of the Host metadata.
 */
declare class Host {
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * An interface that a function passed into {@link forwardRef} has to implement.
 *
 * @usageNotes
 * ### Example
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}
 * @publicApi
 */
declare type ForwardRefFn = () => any;
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
 * a query is not yet defined.
 *
 * @usageNotes
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
 * @publicApi
 */
declare function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;
/** Checks whether a function is wrapped by a `forwardRef`. */
declare function isForwardRef(fn: any): fn is () => any;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
declare function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string;

declare type TypeofInjectionToken<Type> = Type extends InjectionToken<infer X> ? X : never;

/**
 * @hidden
 */
declare class ConstantFormatter {
    format(object: any | It<any>): string;
}

/**
 * @hidden
 */
declare class FunctionFormatter {
    private constantFormatter;
    constructor(constantFormatter: ConstantFormatter);
    format(expression: FunctionExpression): string;
}

/**
 * @hidden
 */
declare class PropertyKeyFormatter {
    format(property: PropertyKey): string;
}

/**
 * @hidden
 */
declare class MethodFormatter {
    private readonly constantFormatter;
    private readonly propertyKeyFormatter;
    constructor(constantFormatter: ConstantFormatter, propertyKeyFormatter: PropertyKeyFormatter);
    format(expression: MethodExpression): string;
}

/**
 * @hidden
 */
declare class NamePrefixProvider {
    get(name: string | undefined): string;
}

/**
 * @hidden
 */
declare class AutoMockNameFormatter {
    private readonly namePrefixProvider;
    private readonly methodFormatter;
    private readonly propertyKeyFormatter;
    private readonly namedMethodFormatter;
    private readonly constantFormatter;
    constructor(namePrefixProvider: NamePrefixProvider, methodFormatter: FunctionFormatter, propertyKeyFormatter: PropertyKeyFormatter, namedMethodFormatter: MethodFormatter, constantFormatter: ConstantFormatter);
    format<T>(name: string | undefined, expression: Expressions<T>): string;
}

/**
 * Provides configuration for an angular based injector that would be used internally for auto mocking feature
 */
declare class AutoMockInjectorConfig implements IInjectorConfig {
    private readonly options;
    private readonly mock;
    private readonly root;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, mock: IMock<unknown>, root: IMock<unknown>);
    get(options: IMockOptions<unknown>, providers: StaticProvider[]): StaticProvider[];
}

/**
 * This class provides configuration for auto mocking mocks
 */
declare class AutoMockOptionsBuilder {
    private readonly options;
    private readonly autoMockNameFormatter;
    private readonly autoMockInjectorConfig;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, autoMockNameFormatter: AutoMockNameFormatter, autoMockInjectorConfig: AutoMockInjectorConfig);
    create<T>(expression: Expressions<T>): IMockOptions<T>;
}

/**
 * @Hidden
 */
declare const MOCK_CONSTRUCTOR: InjectionToken<(opts: IMockOptions<unknown>) => IMock<unknown>>;

/**
 * This service is used to create an instance of a Mock for auto mocking feature
 */
declare class AutoMockFactory {
    private readonly ctor;
    private readonly optionsBuilder;
    constructor(ctor: TypeofInjectionToken<typeof MOCK_CONSTRUCTOR>, optionsBuilder: AutoMockOptionsBuilder);
    create<T>(expression: Expressions<T>): IMock<unknown>;
}

/**
 * This service is an adapter for a resolved promise.
 */
declare class ResolvedPromiseFactory implements InjectionFactory {
    constructor();
    factory(): <T>(value: T) => Promise<T>;
}

/**
 * This service is an adapter for a rejected promise.
 */
declare class RejectedPromiseFactory implements InjectionFactory {
    constructor();
    factory(): <T>(value: T) => Promise<T>;
}

export { APPLY_RETURN_VALUE, AsyncExpressionDetector, AsyncExpressionReflector, AutoMockFactory, AutoMockInjectorConfig, AutoMockOptionsBuilder, CONSTRUCT_RETURN_VALUE, CompositeExpressionReflector, DefaultInjectorConfig, EXPRESSIONS, EXPRESSION_REFLECTOR, EqualMatchingInjectorConfig, Expression, ExpressionReflector, Expressions, FunctionExpression, GET_RETURN_VALUE, GetPropertyExpression, Host, IExpression, IInjectorConfig, IMock, IMockOptions, INJECTOR, IObjectMatcher, IPlayable, IPredicate, IPresetBuilder, IReturnValueFactory, ISequenceVerifier, InOperatorExpression, InjectFlags, InjectionToken, Injector, It, MOCK, MOCK_OPTIONS, MethodExpression, Mock, MoqAPI, NewOperatorExpression, NullInjector, OBJECT_MATCHERS, Optional, PlayTimes, PlayableAlways, PlayableExactly, PlayableNever, PlayableOnce, PlayableSequence, PlayableUpdateReason, PromisedType, Range, RejectedPromiseFactory, ResolvedPromiseFactory, Self, SetPropertyExpression, SkipSelf, StaticProvider, SyncExpressionReflector, Times, TrackedAction, Tracker, TypeofInjectionToken, dump, forwardRef, getClosureSafeProperty, injectorFactory, isForwardRef };
