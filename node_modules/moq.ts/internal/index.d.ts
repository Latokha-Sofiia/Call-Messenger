/**
 * Sets the rules where bounds of a range are included or excluded from the range.
 * See {@link Times.Between}
 */
declare enum Range {
    Exclusive = 0,
    Inclusive = 1
}
/**
 * This class expresses the expectation about amount of invocations.
 *
 * @example
 * ```typescript
 *
 * const times = new Times(expected => expected === 1, `Should be called once`);
 * const actual = times.test(2);
 *
 * expect(actual).toBe(false);
 * expect(times.message).toBe(`Should be called once`);
 * ```
 *
 * ```typescript
 *
 * const mockName = 'mock name';
 *const mock = new Mock<ITestObject>(mockName);
 *const object = mock.object();
 *
 *object.property;
 *
 *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
 *
 *expect(action).toThrow();
 * ```
 */
declare class Times {
    private evaluator;
    message: string;
    private static _once;
    private static _never;
    private static _atMostOnce;
    private static _atLeastOnce;
    /**
     *
     * @param evaluator It takes actual value and decides if it is expected or not.
     * Returns true or false accordingly.
     * @param message A message that describes the expectation.
     */
    constructor(evaluator: (callCount: number) => boolean, message: string);
    /**
     * It expects that the actual would be equal or bigger then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtLeast(callCount: number): Times;
    /**
     * It expects that the actual would be equal or bigger then 1.
     */
    static AtLeastOnce(): Times;
    /**
     * It expects that the actual would be equal or smaller then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtMost(callCount: number): Times;
    /**
     * It expects that the actual would be equal or less then 1.
     */
    static AtMostOnce(): Times;
    /**
     * It expects that the actual would be in the expected range of values.
     *
     * @param callCountFrom The lowest bound of the range.
     * @param callCountTo The highest bound of the range.
     * @param range  Sets the rules where bounds of a range are included or excluded from the range.
     */
    static Between(callCountFrom: number, callCountTo: number, range: Range): Times;
    /**
     * It expects that the actual is equal to the expected value.
     *
     * @param callCount The expected value.
     */
    static Exactly(callCount: number): Times;
    /**
     * It expects that the actual is equal 0.
     */
    static Never(): Times;
    /**
     * It expects that the actual is equal 1.
     */
    static Once(): Times;
    /**
     * Evaluates the expectation against the actual value.
     *
     * @param callCount The actual value.
     */
    test(callCount: number): boolean;
}

declare type IPredicate<T> = (instance: T) => boolean;
/**
 * This class allows to express wide range of cases in an expression.
 * You can use it with setups or verifies methods.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
 *  .returns(value)
 *  .setup(instance => instance(It.IsAny())
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 *
 * This class could be used not only for args matching, but also for function names, property names and so on.
 *
 * @example
 * ```typescript
 *
 * const object = new Mock<ITestObject>()
 * // the expression dynamically checks the property name that is being read
 * .setup(instance => It.Is((expression: GetPropertyExpression) => expression.name === 'property'))
 * .returns(value)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * //denis any write operation on the property
 * .setup(instance => { instance.property = It.IsAny()})
 * // true - allow, false - deny
 * .returns(false)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * .setup(instance => It.Is((expression: NamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
 * .returns(value)
 * .object();
 *
 * // how to use with verify
 * mock.verify(instance => instance.method(It.Is(a => a === 2)));
 * ```
 */
declare class It<P> {
    readonly predicate: IPredicate<P>;
    constructor(predicate: IPredicate<P>);
    /**
     * This factory method returns an expression that matches custom cases.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static Is<T>(predicate: IPredicate<T>): It<T> | any;
    /**
     * This factory method returns a wildcat expression that matches any value.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(any_value_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static IsAny<T>(): It<T> | any;
    private static readonly isAnyPredicate;
    /**
     * Exams if the instance matches the predicate.
     */
    test(instance?: P): boolean;
}

declare abstract class Expression {
    readonly name: PropertyKey;
    readonly args: any[];
    protected constructor(name: PropertyKey, args: any[]);
}
/**
 * This class represents an invocation of an instance method.
 * It provides access to the name of it and the parameters.
 */
declare class MethodExpression extends Expression {
    constructor(name: PropertyKey, args: any[]);
}
/**
 * This class represents an invocation of a function.
 * It provides access to the parameters.
 */
declare class FunctionExpression extends Expression {
    constructor(args: any[]);
}
/**
 * This class represents a property accessing.
 * It provides access to the name of property.
 */
declare class GetPropertyExpression extends Expression {
    constructor(name: PropertyKey);
}
/**
 * This class represents a property write interaction.
 * It provides access to the name of property and the value.
 */
declare class SetPropertyExpression extends Expression {
    readonly value: any;
    constructor(name: PropertyKey, value: any);
}
/**
 * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
 * It provides access to the name of property.
 */
declare class InOperatorExpression extends Expression {
    constructor(name: PropertyKey);
}
/**
 * This class represents applying of [new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).
 * It provides access to the arguments of the constructor.
 */
declare class NewOperatorExpression extends Expression {
    constructor(args: any[]);
}
/**
 * Union of the expressions and It type.
 */
declare type Expressions<T> = FunctionExpression | GetPropertyExpression | SetPropertyExpression | InOperatorExpression | MethodExpression | NewOperatorExpression | It<T>;

/**
 * @hidden
 */
declare class SequenceId {
    private value;
    next(): number;
}

/**
 * This class represents a recorded interaction with the a mocked object.
 */
interface TrackedAction {
    id: number;
    expression: Expression;
}
/**
 * This class records all interactions with a mocked object.
 */
declare class Tracker {
    private sequenceId;
    private log;
    constructor(sequenceId: SequenceId);
    /**
     * @hidden
     */
    add(action: Expression): void;
    /**
     * Returns recorded interactions.
     */
    get(): TrackedAction[];
    interactions(): Expression[];
}

/**
 * @description
 *
 * Represents an abstract class `T`, if applied to a concrete class it would stop being
 * instantiatable.
 *
 * @publicApi
 */
interface AbstractType<T> extends Function {
    prototype: T;
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Represents a type that a Component or other object is instances of.
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @publicApi
 */
declare const Type: FunctionConstructor;
declare type Type<T> = new (...args: any[]) => T;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Configures the `Injector` to return a value for a token.
 * Base for `ValueProvider` decorator.
 *
 * @publicApi
 */
interface ValueSansProvider {
    /**
     * The value to inject.
     */
    useValue: any;
}
/**
 * Configures the `Injector` to return a value for a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ValueProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ValueProvider extends ValueSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return an instance of `useClass` for a token.
 * Base for `StaticClassProvider` decorator.
 *
 * @publicApi
 */
interface StaticClassSansProvider {
    /**
     * An optional class to instantiate for the `token`. By default, the `provide`
     * class is instantiated.
     */
    useClass: Type<any>;
    /**
     * A list of `token`s to be resolved by the injector. The list of values is then
     * used as arguments to the `useClass` constructor.
     */
    deps: any[];
}
/**
 * Configures the `Injector` to return an instance of `useClass` for a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='StaticClassProvider'}
 *
 * Note that following two providers are not equal:
 *
 * {@example core/di/ts/provider_spec.ts region='StaticClassProviderDifference'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface StaticClassProvider extends StaticClassSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return an instance of a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * ```ts
 * @Injectable(SomeModule, {deps: []})
 * class MyService {}
 * ```
 *
 * @publicApi
 */
interface ConstructorSansProvider {
    /**
     * A list of `token`s to be resolved by the injector.
     */
    deps?: any[];
}
/**
 * Configures the `Injector` to return an instance of a token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ConstructorProvider extends ConstructorSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: Type<any>;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return a value of another `useExisting` token.
 *
 * @see `ExistingProvider`
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @publicApi
 */
interface ExistingSansProvider {
    /**
     * Existing `token` to return. (Equivalent to `injector.get(useExisting)`)
     */
    useExisting: any;
}
/**
 * Configures the `Injector` to return a value of another `useExisting` token.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface ExistingProvider extends ExistingSansProvider {
    /**
     * An injection token. Typically an instance of `Type` or `InjectionToken`, but can be `any`.
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Configures the `Injector` to return a value by invoking a `useFactory` function.
 *
 * @see `FactoryProvider`
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @publicApi
 */
interface FactorySansProvider {
    /**
     * A function to invoke to create a value for this `token`. The function is invoked with
     * resolved values of `token`s in the `deps` field.
     */
    useFactory: Function;
    /**
     * A list of `token`s to be resolved by the injector. The list of values is then
     * used as arguments to the `useFactory` function.
     */
    deps?: any[];
}
/**
 * Configures the `Injector` to return a value by invoking a `useFactory` function.
 *
 * @see ["Dependency Injection Guide"](guide/dependency-injection).
 *
 * @usageNotes
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}
 *
 * Dependencies can also be marked as optional:
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}
 *
 * ### Multi-value example
 *
 * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
 *
 * @publicApi
 */
interface FactoryProvider extends FactorySansProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * When true, injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     */
    multi?: boolean;
}
/**
 * Describes how an `Injector` should be configured as static (that is, without reflection).
 * A static provider provides tokens to an injector for various types of dependencies.
 *
 * @see [Injector.create()](/api/core/Injector#create).
 * @see ["Dependency Injection Guide"](guide/dependency-injection-providers).
 *
 * @publicApi
 */
declare type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];

interface InjectionFactory {
    factory(...args: unknown[]): unknown;
}
declare type TypeOfInjectionFactory<T extends InjectionFactory> = ReturnType<T["factory"]>;

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
declare class InjectionToken<T> {
    protected desc: string;
    constructor(desc: string);
    toString(): string;
}

/**
 * A function that accepts a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
 * and either plays expected interaction or returns a predicate function.
 * See {@link IMock.setup} function and {@link It} class for more details.
 */
declare type IExpression<T> = (instance: T) => void | any | It<T>;
/**
 * This class reflects an expression to an expression tree representation.
 */
interface ExpressionReflector {
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect<T>(expression: IExpression<T>): Expressions<T>[];
}
/**
 * Injection token for an expression reflector
 */
declare const EXPRESSION_REFLECTOR: InjectionToken<ExpressionReflector>;
/**
 * @hidden
 */
interface IReturnValueFactory {
    create(): any;
}

declare type PromisedType<T> = T extends Promise<infer P> ? P : never;
declare const enum PlayableUpdateReason {
    /**
     * The playable is update because it's setup is about to be played
     */
    OwnSetupWouldBePlayed = 0,
    /**
     * The playable is update because another setup is about to be played
     */
    OtherSetupWouldBePlayed = 1
}
/**
 * Provides playable logic for a setup
 */
interface IPlayable {
    /**
     * Tests if setup is playable
     */
    isPlayable(): boolean;
    /**
     * Invokes as the setup is about to be played, so the playable logic can change it's state.
     *
     * @param reason The reason why this update is called {@link PlayableUpdateReason}
     * @example
     * ```typescript
     *
     *     const playable1 = new PlayableOnce();
     *     const playable2 = new PlayableOnce();
     *
     *     const mock = new Mock<(val: number) => void)>()
     *     // setup A
     *     .setup(instance => instance(1))
     *     .play(playable1)
     *     .returns(1)
     *     // setup B
     *     .setup(instance => instance(2))
     *     .play(playable2)
     *     .returns(2);
     *
     *     const actual = mock.object()(1);
     *     // at this point the update of playable1 should be called with OwnSetupWouldBePlayed
     *     // because setup A would be played
     *     // and the update of playable2 should be called with OtherSetupWouldBePlayed
     * ```
     */
    update(reason: PlayableUpdateReason): void;
}
/**
 * Sets a behaviour rule for a particular use case
 *
 * @param T The type of mocked object.
 */
interface IPresetBuilder<T, TValue = any> {
    /**
     * Returns the provided value as a result of interaction in case of
     * - get property value
     * - invocation a function
     *
     * Controls write operation in case of
     * - property assignment (true - the assignment is allowed, false - the assignment is not allowed)
     *
     * @param value The value
     */
    returns(value: TValue): IMock<T>;
    /**
     * Returns the provided value with a resolved Promise as a result of invocation an asynchronous function
     *
     * @param value The value
     */
    returnsAsync(value: PromisedType<TValue>): IMock<T>;
    /**
     * Throws the provided exception.
     */
    throws<TException>(exception: TException): IMock<T>;
    /**
     * Returns the provided value with a rejected Promise as a result of interaction with an asynchronous function.
     */
    throwsAsync<TException>(exception: TException): IMock<T>;
    /**
     * @param callback A callback function that will intercept the interaction.
     * The function may returns a value that will be provided as result (see {@link IPresetBuilder.returns})
     * @example
     * ```typescript
     *
     *     const ipcRendererMock = new StrictMock<typeof ipcRenderer>()
     *     .setup(instance => instance.on(ipcRendererChannelName, It.IsAny()))
     *     .callback(({args: [channel, listener]}) => listener(undefined, response));
     * ```
     */
    callback(callback: (interaction: Expression) => TValue): IMock<T>;
    /**
     * Plays the setup on target invocation when predicate returns true otherwise the setup will be ignored.
     * As predicate {@link PlayTimes} could be used.
     */
    play(predicate: IPlayable): IPresetBuilder<T, TValue>;
    /**
     * Replicates interactions with original object.
     * The mock object keeps tracking all interactions and reflects them on the original object.
     *
     * @example
     * ```typescript
     *
     * const value = 2;
     *
     * class Origin {
     *   public property = value;
     *}
     *
     * const origin = new Origin();
     * const mock = new Mock<Origin>()
     * .setup(() => It.IsAny())
     * .mimics(origin);
     *
     * const actual = mock.object().property;
     * expect(actual).toBe(2);
     * ```
     */
    mimics(origin: T): IMock<T>;
}
/**
 * The main API of the framework.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 * ---
 * #### Latest setups have more precedence over earlier setups.
 * @example
 * ```typescript
 *
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(1)
 *  .setup(instance => instance(1))
 *  .returns(2)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(2);
 * ```
 *
 * @param T The type of mocked object. Could be any type including:
 * - Function,
 * - arrow function,
 * - interface,
 * - class,
 * - object and etc.
 */
interface IMock<T> {
    /**
     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct
     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].
     */
    readonly name?: string;
    /**
     * Returns the tracker object that responsible for storing history of interactions with the mocked object.
     */
    readonly tracker: Tracker;
    /**
     * Returns options object
     */
    readonly options: IMockOptions<T>;
    /**
     * Returns instance of mocked object
     */
    object(): T;
    /**
     * Defines a configuration for particular interaction with the mocked object.
     *
     * @example
     * ```typescript
     *
     * // a function invoke with 1 as parameter
     * .setup(instance => instance(1))
     *
     * // apply function invoke on a function with null as the first parameter and a placeholder for the second parameter
     * .setup(instance => instance.apply(null, It.IsAny()))
     *
     * // accessing to a property
     * .setup(instance => instance.property)
     *
     * //accessing to a named function with name 'test' of an object and the first parameter is 1
     * .setup(instance => It.Is((expression: NamedMethodExpression) => {
     *      return expression.name === 'test' && expression.args[0] === 1
     * }))
     *
     * //setting propertyA to value of 'a'
     * .setup(instance => {instance.propertyA = 'a'})
     * ```
     * @param expression A function that accepts a
     * [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
     * and either plays expected interaction or returns a predicate function.
     * Refer {@link It} class for parameter placeholders or predicate functions.
     * Refer the integration tests for more examples.
     * @returns PresetBuilder config interface for the provided expression.
     */
    setup<E extends IExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    /**
     * Asserts expected interactions with the mocked object.
     *
     * @param expression Expected expression
     * @param times The default value is {@link Times.Once()}
     */
    verify(expression: IExpression<T>, times?: Times): IMock<T>;
    /**
     * Set the prototype of the mocked object.
     *
     * @example
     * ```typescript
     *
     *  class PrototypeClass {}
     *
     *  const mock = new Mock<{}>();
     *  const object = mock.object();
     *
     *  Object.setPrototypeOf(object, PrototypeClass.prototype);
     *
     *  expect(object instanceof PrototypeClass).toBe(true);
     * ```
     */
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     * @hidden
     */
    insequence(sequence: ISequenceVerifier, expression: IExpression<T>): IMock<T>;
    /**
     * Retrieves an instance from the injector based on the provided token.
     *
     * @returns The instance from the injector if defined, otherwise null.
     */
    resolve<S, R = S extends InjectionFactory ? TypeOfInjectionFactory<S> : S>(token: Type<S> | InjectionToken<S>): R;
}
/**
 * @hidden
 * @experimental
 */
interface ISequenceVerifier {
    add<T>(mock: IMock<T>, expression: IExpression<T>): ISequenceVerifier;
    verify(times?: Times): void;
}
/**
 * The Mock internally depends on angular based injector to construct its dependencies.
 */
interface IInjectorConfig {
    /**
     * Returns array of StaticProviders to construct an angular based injector.
     *
     * @param options The final version of mock options. Options that passed to Mock constructor are merged with
     * the global mock options ({@link Mock.options}). Some components depend on the options and the injector
     * should be able to resolve it. To configure the injector property the implementation could do the following:
     * ``` typescript
     * return [
     *  {provide: MOCK_OPTIONS, useValue: options, deps: []},
     * ];
     * ```
     * @param providers An array of additional providers that could be added to the final configuration.
     */
    get(options: IMockOptions<unknown>, ...providers: StaticProvider[]): StaticProvider[];
}
/**
 * Mock instance options.
 * Could be passed as parameter on mock instantiating or could be set globally on {@link Mock.options}.
 */
interface IMockOptions<T> {
    /**
     * You can name the mock. The name will be displayed with any relative output, so you can easily distinct
     * output of several mocks. On the mocked object you can find this name at 'mockName' property of the [[Handler]].
     */
    name?: string;
    /**
     * The target object for Proxy that is used under the hood.
     * typeof operation is applied to this target.
     * The default value is a function.
     */
    target?: T;
    /**
     * The Mock internally based on angular injector to construct its dependencies.
     * An instance of {@link IInjectorConfig} implementation could be passed as parameter in order to
     * changed the mock behaviour. The default value is an instance of {@link DefaultInjectorConfig}.
     * There is also {@link EqualMatchingInjectorConfig} that would setup Mock to use equal logic for comparing values.
     */
    injectorConfig?: IInjectorConfig;
}

declare type TypeofInjectionToken<Type> = Type extends InjectionToken<infer X> ? X : never;

/**
 * @hidden
 */
declare const MOCK_OPTIONS: InjectionToken<IMockOptions<any>>;

/**
 * @hidden
 */
declare class ConstantFormatter {
    format(object: any | It<any>): string;
}

/**
 * @hidden
 */
declare class FunctionFormatter {
    private constantFormatter;
    constructor(constantFormatter: ConstantFormatter);
    format(expression: FunctionExpression): string;
}

/**
 * @hidden
 */
declare class PropertyKeyFormatter {
    format(property: PropertyKey): string;
}

/**
 * @hidden
 */
declare class MethodFormatter {
    private readonly constantFormatter;
    private readonly propertyKeyFormatter;
    constructor(constantFormatter: ConstantFormatter, propertyKeyFormatter: PropertyKeyFormatter);
    format(expression: MethodExpression): string;
}

/**
 * @hidden
 */
declare class NamePrefixProvider {
    get(name: string | undefined): string;
}

/**
 * @hidden
 */
declare class AutoMockNameFormatter {
    private readonly namePrefixProvider;
    private readonly methodFormatter;
    private readonly propertyKeyFormatter;
    private readonly namedMethodFormatter;
    private readonly constantFormatter;
    constructor(namePrefixProvider: NamePrefixProvider, methodFormatter: FunctionFormatter, propertyKeyFormatter: PropertyKeyFormatter, namedMethodFormatter: MethodFormatter, constantFormatter: ConstantFormatter);
    format<T>(name: string | undefined, expression: Expressions<T>): string;
}

/**
 * Provides configuration for an angular based injector that would be used internally for auto mocking feature
 */
declare class AutoMockInjectorConfig implements IInjectorConfig {
    private readonly options;
    private readonly mock;
    private readonly root;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, mock: IMock<unknown>, root: IMock<unknown>);
    get(options: IMockOptions<unknown>, providers: StaticProvider[]): StaticProvider[];
}

/**
 * This class provides configuration for auto mocking mocks
 */
declare class AutoMockOptionsBuilder {
    private readonly options;
    private readonly autoMockNameFormatter;
    private readonly autoMockInjectorConfig;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, autoMockNameFormatter: AutoMockNameFormatter, autoMockInjectorConfig: AutoMockInjectorConfig);
    create<T>(expression: Expressions<T>): IMockOptions<T>;
}

/**
 * @Hidden
 */
declare const MOCK_CONSTRUCTOR: InjectionToken<(opts: IMockOptions<unknown>) => IMock<unknown>>;

/**
 * This service is used to create an instance of a Mock for auto mocking feature
 */
declare class AutoMockFactory {
    private readonly ctor;
    private readonly optionsBuilder;
    constructor(ctor: TypeofInjectionToken<typeof MOCK_CONSTRUCTOR>, optionsBuilder: AutoMockOptionsBuilder);
    create<T>(expression: Expressions<T>): IMock<unknown>;
}

/**
 * This service provides access to all auto mocked instances
 */
declare class AutoMockedStorage implements InjectionFactory {
    constructor();
    factory(): Map<Expressions<unknown>, IMock<unknown>>;
}

/**
 * @hidden
 */
declare class GetPropertyEqualityComparer {
    equals(left: GetPropertyExpression, right: GetPropertyExpression): boolean;
}

/**
 * @hidden
 */
declare class ItEqualityComparer {
    equals<T>(left: any | It<T>, right: any | It<T>): boolean;
}

/**
 * @hidden
 */
declare class ConstantEqualityComparer {
    private readonly itEqualityComparer;
    constructor(itEqualityComparer: ItEqualityComparer);
    equals(left: any, right: any): boolean;
}

/**
 * @hidden
 */
declare class SetPropertyEqualityComparer {
    private readonly constantMatcher;
    constructor(constantMatcher: ConstantEqualityComparer);
    equals(left: SetPropertyExpression, right: SetPropertyExpression): boolean;
}

/**
 * @hidden
 */
declare class ArgumentsEqualityComparer {
    private readonly constantMatcher;
    constructor(constantMatcher: ConstantEqualityComparer);
    equals(left: any[], right: any[]): boolean;
}

/**
 * @hidden
 */
declare class MethodEqualityComparer {
    private readonly argumentsMatcher;
    constructor(argumentsMatcher: ArgumentsEqualityComparer);
    equals(left: FunctionExpression, right: FunctionExpression): boolean;
}

/**
 * @hidden
 */
declare class InstanceMethodEqualityComparer {
    private readonly argumentsMatcher;
    constructor(argumentsMatcher: ArgumentsEqualityComparer);
    equals(left: MethodExpression, right: MethodExpression): boolean;
}

/**
 * @hidden
 */
declare class InOperatorEqualityComparer {
    equals(left: InOperatorExpression, right: InOperatorExpression): boolean;
}

/**
 * @hidden
 */
declare class NewOperatorEqualityComparer {
    private readonly argumentsMatcher;
    constructor(argumentsMatcher: ArgumentsEqualityComparer);
    equals(left: NewOperatorExpression, right: NewOperatorExpression): boolean;
}

/**
 * @hidden
 */
declare class ExpressionEqualityComparer {
    private readonly getPropertyExpressionMatcher;
    private readonly setPropertyExpressionMatcher;
    private readonly methodExpressionMatcher;
    private readonly namedMethodExpressionMatcher;
    private readonly inOperatorExpressionMatcher;
    private readonly newOperatorExpressionMatcher;
    private readonly itEqualityComparer;
    constructor(getPropertyExpressionMatcher: GetPropertyEqualityComparer, setPropertyExpressionMatcher: SetPropertyEqualityComparer, methodExpressionMatcher: MethodEqualityComparer, namedMethodExpressionMatcher: InstanceMethodEqualityComparer, inOperatorExpressionMatcher: InOperatorEqualityComparer, newOperatorExpressionMatcher: NewOperatorEqualityComparer, itEqualityComparer: ItEqualityComparer);
    equals<T>(left: Expressions<T>, right: Expressions<T>): boolean;
}

/**
 * @hidden
 */
declare class AutoMockProvider {
    private readonly map;
    private readonly comparer;
    private readonly autoMockFactory;
    constructor(map: TypeOfInjectionFactory<AutoMockedStorage>, comparer: ExpressionEqualityComparer, autoMockFactory: AutoMockFactory);
    getOrCreate<T>(expression: Expressions<T>): IMock<unknown>;
}

declare class FunctionExpressionValidator {
    validate({ args }: FunctionExpression): boolean;
}

declare class GetPropertyExpressionValidator {
    validate({ name }: GetPropertyExpression): boolean;
}

declare class SetPropertyExpressionValidator {
    validate({ name, value }: SetPropertyExpression): boolean;
}

declare class InstanceMethodExpressionValidator {
    validate({ name, args }: MethodExpression): boolean;
}

declare class NewOperatorExpressionValidator {
    validate({ args }: NewOperatorExpression): boolean;
}

declare class InOperatorExpressionValidator {
    validate({ name }: InOperatorExpression): boolean;
}

declare class ExpressionValidator {
    private readonly functionExpressionGuard;
    private readonly getPropertyExpressionGuard;
    private readonly setPropertyExpressionGuard;
    private readonly inOperatorExpressionGuard;
    private readonly instanceMethodExpressionGuard;
    private readonly newOperatorExpressionGuard;
    constructor(functionExpressionGuard: FunctionExpressionValidator, getPropertyExpressionGuard: GetPropertyExpressionValidator, setPropertyExpressionGuard: SetPropertyExpressionValidator, inOperatorExpressionGuard: InOperatorExpressionValidator, instanceMethodExpressionGuard: InstanceMethodExpressionValidator, newOperatorExpressionGuard: NewOperatorExpressionValidator);
    validate(expression: Expressions<unknown>): boolean;
}

declare class ExpressionFormatter {
    private readonly functionFormatter;
    private readonly propertyKeyFormatter;
    private readonly instanceMethodFormatter;
    private readonly constantFormatter;
    constructor(functionFormatter: FunctionFormatter, propertyKeyFormatter: PropertyKeyFormatter, instanceMethodFormatter: MethodFormatter, constantFormatter: ConstantFormatter);
    format(expression: Expressions<unknown>, name: string): string;
}

declare class StringErrorStyler {
    style(value: string): string;
}

declare class ComplexExpressionErrorFormatter {
    private readonly options;
    private readonly namePrefixProvider;
    private readonly expressionFormatter;
    private readonly errorStyler;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, namePrefixProvider: NamePrefixProvider, expressionFormatter: ExpressionFormatter, errorStyler: StringErrorStyler);
    format(expressions: [Expressions<unknown>, boolean][]): string;
}

declare class ExpressionGuardExceptionFactory {
    private readonly formatter;
    constructor(formatter: ComplexExpressionErrorFormatter);
    create(expressions: [Expressions<unknown>, boolean][]): Error;
}

declare class ComplexExpressionValidator {
    private readonly validator;
    constructor(validator: ExpressionValidator);
    validate(expressions: Expressions<unknown>[]): {
        valid: boolean;
        errors: [Expressions<unknown>, boolean][];
    };
}

declare class ComplexExpressionGuard {
    private readonly complexExpressionValidator;
    private readonly expressionGuardExceptionFactory;
    constructor(complexExpressionValidator: ComplexExpressionValidator, expressionGuardExceptionFactory: ExpressionGuardExceptionFactory);
    verify(expressions: Expressions<unknown>[]): void;
}

/**
 * @hidden
 */
declare class RootMockProvider implements InjectionFactory {
    private readonly mock;
    private readonly root;
    constructor(mock: IMock<unknown>, root: IMock<unknown>);
    factory(): IMock<unknown>;
}

declare class PropertiesValueStorage {
    private storage;
    has(property: PropertyKey): boolean;
    get(property: PropertyKey): any;
    set(property: PropertyKey, value: any): void;
}

interface IPreset<T> {
    readonly target: Expressions<T>;
    readonly playable: IPlayable;
}

/**
 * @hidden
 */
declare class Presets<T> {
    private presets;
    add(preset: IPreset<T>): void;
    get(): IPreset<T>[];
}

/**
 * @hidden
 */
declare class PlayablePresetProvider {
    private presets;
    private matcher;
    constructor(presets: Presets<unknown>, matcher: ExpressionEqualityComparer);
    get(interaction: Expression): IPreset<unknown> | undefined;
}

/**
 * @hidden
 */
declare class CallbackPresetPlayer {
    play<TValue>(callback: (interaction: Expression) => TValue, interaction: Expression): any;
}

/**
 * @hidden
 */
declare const REFLECT_APPLY: InjectionToken<typeof Reflect.apply>;

/**
 * @hidden
 */
declare class MimicsPresetPlayer {
    private apply;
    constructor(apply: TypeofInjectionToken<typeof REFLECT_APPLY>);
    play(origin: any, interaction: Expression): any;
}

/**
 * @hidden
 */
declare class PresetPlayer {
    private callbackPresetPlayer;
    private mimicsPresetPlayer;
    constructor(callbackPresetPlayer: CallbackPresetPlayer, mimicsPresetPlayer: MimicsPresetPlayer);
    play<T>(preset: IPreset<T>, interaction: Expression): any;
}

/**
 * @hidden
 */
declare class PresetPlayablesUpdater {
    private presets;
    private matcher;
    constructor(presets: Presets<unknown>, matcher: ExpressionEqualityComparer);
    update(interaction: Expression, playable: IPreset<unknown>): void;
}

/**
 * @hidden
 */
declare class InteractionPlayer {
    private playablePresetProvider;
    private presetPlayablesUpdater;
    private presetPlayer;
    constructor(playablePresetProvider: PlayablePresetProvider, presetPlayablesUpdater: PresetPlayablesUpdater, presetPlayer: PresetPlayer);
    play(interaction: Expression): any;
}

/**
 * @hidden
 */
declare class SpyFunctionProvider {
    private tracker;
    private interactionPlayer;
    private map;
    constructor(tracker: Tracker, interactionPlayer: InteractionPlayer);
    get(property: PropertyKey): (...args: any[]) => any;
}

/**
 * @hidden
 */
declare class ExpressionHasPropertyExplorer {
    has(name: PropertyKey, expression: Expressions<unknown>): boolean;
}

/**
 * @hidden
 */
declare class ObjectHasPropertyExplorer {
    has(name: PropertyKey, target: any): boolean;
}

/**
 * @hidden
 */
declare class PresetHasPropertyExplorer {
    private expressionHasPropertyExplorer;
    private objectHasPropertyExplorer;
    constructor(expressionHasPropertyExplorer: ExpressionHasPropertyExplorer, objectHasPropertyExplorer: ObjectHasPropertyExplorer);
    has(name: PropertyKey, preset: IPreset<unknown>): boolean;
}

/**
 * @hidden
 */
declare class PrototypeStorage {
    private prototype;
    constructor(mockTarget: any);
    get(): any;
    set(prototype: any): void;
}

/**
 * @hidden
 */
declare class PropertyDescriptorProvider {
    get(target: any, name: PropertyKey): PropertyDescriptor;
}

/**
 * @hidden
 */
declare const REFLECT_HAS: InjectionToken<typeof Reflect.has>;

/**
 * @hidden
 */
declare class MembersPropertyExplorer {
    private storage;
    private propertyDescriptorProvider;
    private has;
    constructor(storage: PrototypeStorage, propertyDescriptorProvider: PropertyDescriptorProvider, has: TypeofInjectionToken<typeof REFLECT_HAS>);
    hasProperty(name: PropertyKey): boolean;
}

/**
 * @hidden
 */
declare class HasPropertyExplorer {
    private presets;
    private membersExplorer;
    private explorer;
    constructor(presets: Presets<unknown>, membersExplorer: MembersPropertyExplorer, explorer: PresetHasPropertyExplorer);
    has(name: PropertyKey): boolean;
}

/**
 * @hidden
 */
declare class ExpressionHasMethodExplorer {
    has(name: PropertyKey, expression: Expressions<unknown>): boolean;
}

/**
 * @hidden
 */
declare class ObjectHasMethodExplorer {
    has(name: PropertyKey, target: any): boolean;
}

/**
 * @hidden
 */
declare class PresetHasMethodExplorer {
    private expressionHasMethodExplorer;
    private objectHasMethodExplorer;
    constructor(expressionHasMethodExplorer: ExpressionHasMethodExplorer, objectHasMethodExplorer: ObjectHasMethodExplorer);
    has(name: PropertyKey, preset: IPreset<unknown>): boolean;
}

/**
 * @hidden
 */
declare class MembersMethodExplorer {
    private storage;
    private propertyDescriptorProvider;
    private has;
    constructor(storage: PrototypeStorage, propertyDescriptorProvider: PropertyDescriptorProvider, has: TypeofInjectionToken<typeof REFLECT_HAS>);
    hasMethod(name: PropertyKey): boolean;
}

/**
 * @hidden
 */
declare class HasMethodExplorer {
    private presets;
    private membersExplorer;
    private explorer;
    constructor(presets: Presets<unknown>, membersExplorer: MembersMethodExplorer, explorer: PresetHasMethodExplorer);
    has(name: PropertyKey): boolean;
}

/**
 * @Hidden
 */
declare const MOCK: InjectionToken<IMock<unknown>>;

/**
 * @hidden
 */
declare class GetTrap {
    private mock;
    private tracker;
    private propertiesValueStorage;
    private interactionPlayer;
    private hasPropertyExplorer;
    private hasMethodExplorer;
    private spyFunctionProvider;
    constructor(mock: TypeofInjectionToken<typeof MOCK>, tracker: Tracker, propertiesValueStorage: PropertiesValueStorage, interactionPlayer: InteractionPlayer, hasPropertyExplorer: HasPropertyExplorer, hasMethodExplorer: HasMethodExplorer, spyFunctionProvider: SpyFunctionProvider);
    intercept(property: PropertyKey): any;
}

/**
 * @hidden
 */
declare class PropertyIsReadOnlyTester {
    private storage;
    private propertyDescriptorProvider;
    private has;
    constructor(storage: PrototypeStorage, propertyDescriptorProvider: PropertyDescriptorProvider, has: TypeofInjectionToken<typeof REFLECT_HAS>);
    isReadOnly(name: PropertyKey): boolean;
}

/**
 * @hidden
 */
declare class SetTrap {
    private tracker;
    private propertiesValueStorage;
    private interactionPlayer;
    private propertyIsReadOnlyTester;
    constructor(tracker: Tracker, propertiesValueStorage: PropertiesValueStorage, interactionPlayer: InteractionPlayer, propertyIsReadOnlyTester: PropertyIsReadOnlyTester);
    intercept(target: any, property: PropertyKey, value: any): boolean;
}

/**
 * @hidden
 */
declare class ApplyTrap {
    private tracker;
    private interactionPlayer;
    constructor(tracker: Tracker, interactionPlayer: InteractionPlayer);
    intercept(target: any, thisArg: any, argArray?: any): any;
}

/**
 * @hidden
 */
declare class GetPrototypeOfTrap {
    private prototypeStorage;
    constructor(prototypeStorage: PrototypeStorage);
    intercept(): any;
}

/**
 * @hidden
 */
declare class SetPrototypeOfTrap {
    private prototypeStorage;
    constructor(prototypeStorage: PrototypeStorage);
    intercept(prototype: any): any;
}

/**
 * @hidden
 */
declare class PresetHasInOperatorExplorer {
    has(name: PropertyKey, preset: IPreset<unknown>): boolean;
}

/**
 * @hidden
 */
declare class InOperatorInteractionExplorer {
    private presets;
    private explorer;
    constructor(presets: Presets<unknown>, explorer: PresetHasInOperatorExplorer);
    has(name: PropertyKey): boolean;
}

/**
 * @hidden
 */
declare class HasTrap {
    private readonly tracker;
    private readonly propertiesValueStorage;
    private readonly interactionPlayer;
    private readonly inOperatorInteractionExplorer;
    private readonly hasPropertyExplorer;
    private readonly hasMethodExplorer;
    private readonly presetPlayablesUpdater;
    constructor(tracker: Tracker, propertiesValueStorage: PropertiesValueStorage, interactionPlayer: InteractionPlayer, inOperatorInteractionExplorer: InOperatorInteractionExplorer, hasPropertyExplorer: HasPropertyExplorer, hasMethodExplorer: HasMethodExplorer, presetPlayablesUpdater: PresetPlayablesUpdater);
    intercept(property: PropertyKey): any;
}

/**
 * @hidden
 */
declare class ConstructTrap {
    private tracker;
    private interactionPlayer;
    constructor(tracker: Tracker, interactionPlayer: InteractionPlayer);
    intercept(args: any[]): any;
}

/**
 * @hidden
 */
declare class ProxyFactory<T> {
    private readonly options;
    private readonly getTrap;
    private readonly setTrap;
    private readonly hasTrap;
    private readonly applyTrap;
    private readonly getPrototypeOfTrap;
    private readonly setPrototypeOfTrap;
    private readonly constructTrap;
    private _proxy;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, getTrap: GetTrap, setTrap: SetTrap, hasTrap: HasTrap, applyTrap: ApplyTrap, getPrototypeOfTrap: GetPrototypeOfTrap, setPrototypeOfTrap: SetPrototypeOfTrap, constructTrap: ConstructTrap);
    object(): T;
    private createObject;
}

/**
 * @hidden
 */
declare class CallCounter {
    private readonly comparer;
    private readonly tracker;
    constructor(comparer: ExpressionEqualityComparer, tracker: Tracker);
    count<T>(expected: Expressions<T>): number;
}

/**
 * @hidden
 */
declare class GetPropertyFormatter {
    private readonly propertyKeyFormatter;
    constructor(propertyKeyFormatter: PropertyKeyFormatter);
    format(interaction: GetPropertyExpression): string;
}

/**
 * @hidden
 */
declare class SetPropertyFormatter {
    private constantFormatter;
    private propertyKeyFormatter;
    constructor(constantFormatter: ConstantFormatter, propertyKeyFormatter: PropertyKeyFormatter);
    format(expression: SetPropertyExpression): string;
}

/**
 * @hidden
 */
declare class InOperatorFormatter {
    private propertyKeyFormatter;
    constructor(propertyKeyFormatter: PropertyKeyFormatter);
    format(expression: InOperatorExpression): string;
}

/**
 * @hidden
 */
declare class NewOperatorFormatter {
    private constantFormatter;
    constructor(constantFormatter: ConstantFormatter);
    format(expression: NewOperatorExpression): string;
}

/**
 * @hidden
 */
declare class InteractionFormatter {
    private readonly getPropertyFormatter;
    private readonly setPropertyFormatter;
    private readonly methodFormatter;
    private readonly namedMethodFormatter;
    private readonly constantFormatter;
    private readonly inOperatorFormatter;
    private readonly newOperatorFormatter;
    constructor(getPropertyFormatter: GetPropertyFormatter, setPropertyFormatter: SetPropertyFormatter, methodFormatter: FunctionFormatter, namedMethodFormatter: MethodFormatter, constantFormatter: ConstantFormatter, inOperatorFormatter: InOperatorFormatter, newOperatorFormatter: NewOperatorFormatter);
    format(interaction: Expression | It<any>): string;
}

/**
 * @hidden
 */
declare class ExpressionsFormatter {
    private readonly interactionFormatter;
    private readonly options;
    constructor(interactionFormatter: InteractionFormatter, options: TypeofInjectionToken<typeof MOCK_OPTIONS>);
    format(expression: Expressions<any>, timesMessage: string, haveBeenCalledTimes: number): string;
}

/**
 * @hidden
 */
declare class TrackedExpressionsFormatter {
    private interactionFormatter;
    constructor(interactionFormatter: InteractionFormatter);
    format(trackedExpressions: Expression[]): string;
}

/**
 * @hidden
 */
declare class VerifyFormatter {
    private readonly expressionsFormatter;
    private readonly trackedExpressionsFormatter;
    private readonly tracker;
    constructor(expressionsFormatter: ExpressionsFormatter, trackedExpressionsFormatter: TrackedExpressionsFormatter, tracker: Tracker);
    format(expected: Expressions<any>, timesMessage: string, haveBeenCalledTimes: number): string;
}

/**
 * @hidden
 */
declare class VerificationTester {
    private readonly verifyFormatter;
    constructor(verifyFormatter: VerifyFormatter);
    test(expression: Expressions<any>, callCount: number, times: Times): void;
}

/**
 * @hidden
 */
declare class Verifier<T> {
    private readonly callCounter;
    private readonly verificationTester;
    private readonly autoMockProvider;
    constructor(callCounter: CallCounter, verificationTester: VerificationTester, autoMockProvider: AutoMockProvider);
    test([shallow, ...rest]: Expressions<T>[], times: Times): void;
}

/**
 * @Hidden
 */
declare class ReturnsPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    constructor(rootMock: IMock<T>, presets: Presets<T>);
    factory(): (target: Expressions<T>, playable: IPlayable, value: TValue) => IMock<T>;
}

/**
 * @Hidden
 */
declare class MimicsPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    constructor(rootMock: IMock<T>, presets: Presets<T>);
    factory(): (target: Expressions<T>, playable: IPlayable, origin: T) => IMock<T>;
}

/**
 * @Hidden
 */
declare class CallbackPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    constructor(rootMock: IMock<T>, presets: Presets<T>);
    factory(): (target: Expressions<T>, playable: IPlayable, callback: (interaction: Expression) => TValue) => IMock<T>;
}

/**
 * @Hidden
 */
declare class ThrowsPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    constructor(rootMock: IMock<T>, presets: Presets<T>);
    factory(): <TException>(target: Expressions<T>, playable: IPlayable, exception: TException) => IMock<T>;
}

/**
 * This service is an adapter for a resolved promise.
 */
declare class ResolvedPromiseFactory implements InjectionFactory {
    constructor();
    factory(): <T>(value: T) => Promise<T>;
}

/**
 * @Hidden
 */
declare class ReturnsAsyncPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    private readonly resolvedPromise;
    constructor(rootMock: IMock<T>, presets: Presets<T>, resolvedPromise: TypeOfInjectionFactory<ResolvedPromiseFactory>);
    factory(): (target: Expressions<T>, playable: IPlayable, value: PromisedType<TValue>) => IMock<T>;
}

/**
 * This service is an adapter for a rejected promise.
 */
declare class RejectedPromiseFactory implements InjectionFactory {
    constructor();
    factory(): <T>(value: T) => Promise<T>;
}

/**
 * @Hidden
 */
declare class ThrowsAsyncPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    private readonly rejectedPromise;
    constructor(rootMock: IMock<T>, presets: Presets<T>, rejectedPromise: TypeOfInjectionFactory<RejectedPromiseFactory>);
    factory(): <TException>(target: Expressions<T>, playable: IPlayable, exception: TException) => IMock<T>;
}

/**
 * The default implementation of {@link IPresetBuilder} interface.
 * Is it not intended to be used outside of the moq library.
 *
 * @hidden
 */
declare class PresetBuilder<T, TValue = any> implements IPresetBuilder<T> {
    private readonly returnsPresetFactory;
    private readonly throwsPresetFactory;
    private readonly mimicsPresetFactory;
    private readonly callbackPresetFactory;
    private readonly returnsAsyncPresetFactory;
    private readonly throwsAsyncPresetFactory;
    private readonly target;
    private playable;
    constructor(returnsPresetFactory: TypeOfInjectionFactory<ReturnsPresetFactory<T, TValue>>, throwsPresetFactory: TypeOfInjectionFactory<ThrowsPresetFactory<T, TValue>>, mimicsPresetFactory: TypeOfInjectionFactory<MimicsPresetFactory<T, TValue>>, callbackPresetFactory: TypeOfInjectionFactory<CallbackPresetFactory<T, TValue>>, returnsAsyncPresetFactory: TypeOfInjectionFactory<ReturnsAsyncPresetFactory<T, TValue>>, throwsAsyncPresetFactory: TypeOfInjectionFactory<ThrowsAsyncPresetFactory<T, TValue>>, target: Expressions<T>, playable?: IPlayable);
    returnsAsync(value: PromisedType<TValue>): IMock<T>;
    throwsAsync<TException>(exception: TException): IMock<T>;
    mimics(origin: T): IMock<T>;
    returns(value: TValue): IMock<T>;
    throws<TException>(exception: TException): IMock<T>;
    callback(callback: (interaction: Expression) => TValue): IMock<T>;
    play(playable: IPlayable): IPresetBuilder<T>;
}

/**
 * @hidden
 */
declare class PresetBuilderFactory<T> implements InjectionFactory {
    private readonly returnsPresetFactory;
    private readonly throwsPresetFactory;
    private readonly mimicsPresetFactory;
    private readonly callbackPresetFactory;
    private readonly returnsAsyncPresetFactory;
    private readonly throwsAsyncPresetFactory;
    constructor(returnsPresetFactory: TypeOfInjectionFactory<ReturnsPresetFactory<T>>, throwsPresetFactory: TypeOfInjectionFactory<ThrowsPresetFactory<T>>, mimicsPresetFactory: TypeOfInjectionFactory<MimicsPresetFactory<T>>, callbackPresetFactory: TypeOfInjectionFactory<CallbackPresetFactory<T>>, returnsAsyncPresetFactory: TypeOfInjectionFactory<ReturnsAsyncPresetFactory<T>>, throwsAsyncPresetFactory: TypeOfInjectionFactory<ThrowsAsyncPresetFactory<T>>);
    factory(): (target: Expressions<T>) => PresetBuilder<T, any>;
}

/**
 * @Hidden
 */
declare class SetupFactory<T> {
    private readonly presetBuilderFactory;
    private readonly autoMockProvider;
    private readonly expressionGuard;
    constructor(presetBuilderFactory: TypeOfInjectionFactory<PresetBuilderFactory<T>>, autoMockProvider: AutoMockProvider, expressionGuard: ComplexExpressionGuard);
    create<R = unknown>([shallow, ...rest]: Expressions<T>[]): IPresetBuilder<T, R>;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection flags for DI.
 *
 * @publicApi
 */
declare enum InjectFlags {
    /** Check self and check parent injector if needed */
    Default = 0,
    /**
     * Specifies that an injector should retrieve a dependency from any injector until reaching the
     * host element of the current component. (Only used with Element Injector)
     */
    Host = 1,
    /** Don't ascend to ancestors of the node requesting injection. */
    Self = 2,
    /** Skip the node that is requesting injection. */
    SkipSelf = 4,
    /** Inject `defaultValue` instead if token not found. */
    Optional = 8
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Concrete injectors implement this interface. Injectors are configured
 * with [providers](guide/glossary#provider) that associate
 * dependencies of various types with [injection tokens](guide/glossary#di-token).
 *
 * @see ["DI Providers"](guide/dependency-injection-providers).
 * @see `StaticProvider`
 *
 * @usageNotes
 *
 *  The following example creates a service injector instance.
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Usage example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @publicApi
 */
declare abstract class Injector {
    static THROW_IF_NOT_FOUND: {};
    static NULL: Injector;
    /**
     * @internal
     * @nocollapse
     */
    static __NG_ELEMENT_ID__: number;
    /**
     * Creates a new injector instance that provides one or more dependencies,
     * according to a given type or types of `StaticProvider`.
     *
     * @param options An object with the following properties:
     * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).
     * * `parent`: (optional) A parent injector.
     * * `name`: (optional) A developer-defined identifying name for the new injector.
     *
     * @returns The new injector instance.
     *
     */
    static create(options: {
        providers: StaticProvider[];
        parent?: Injector;
        name?: string;
    }): Injector;
    /**
     * Retrieves an instance from the injector based on the provided token.
     *
     * @returns The instance from the injector if defined, otherwise the `notFoundValue`.
     * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.
     */
    abstract get<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;
}

/**
 * The internal core of {@link Mock} class.
 */
declare class MockCore<T> implements IMock<T> {
    readonly options: TypeofInjectionToken<typeof MOCK_OPTIONS>;
    readonly tracker: Tracker;
    private readonly injector;
    private readonly reflector;
    private readonly interceptor;
    private readonly verifier;
    private readonly prototypeStorage;
    private readonly mock;
    private readonly setupFactory;
    constructor(options: TypeofInjectionToken<typeof MOCK_OPTIONS>, tracker: Tracker, injector: Injector, reflector: TypeofInjectionToken<typeof EXPRESSION_REFLECTOR>, interceptor: ProxyFactory<T>, verifier: Verifier<T>, prototypeStorage: PrototypeStorage, mock: TypeofInjectionToken<typeof MOCK>, setupFactory: SetupFactory<T>);
    get name(): string;
    resolve<S, R = S extends InjectionFactory ? ReturnType<S["factory"]> : S>(token: Type<S> | InjectionToken<S>): R;
    setup<E extends IExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    verify(expression: IExpression<T>, times: Times): IMock<T>;
    object(): T;
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     */
    insequence(sequence: ISequenceVerifier, expression: IExpression<T>): IMock<T>;
}

/**
 * @hidden
 */
declare class CommonTypeProvider {
    ofType(left: unknown, right: unknown): "" | "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
}

/**
 *  A custom matcher should implement this interface and be registered with EqualMatchingInjectorConfig.
 *  The parameters are always are not null or undefined and they are always not equal (!==).
 *
 *  @return undefined if the matcher is not intended to compare objects of such type, otherwise result of comparision.
 *
 *  ``` typescript
 *  // A custom matcher that matches Moment and Date objects
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *      matched<T extends object>(left: T, right: T): boolean | undefined {
 *          if (left instanceof Date && isMoment(right)) {
 *              return left.valueOf() === right.valueOf();
 *          }
 *          return undefined;
 *      }
 *  }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *      provide: OBJECT_MATCHERS,
 *      useClass: MomentDateMatcher,
 *      multi: true,
 *      deps: []
 *  }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 */
interface IObjectMatcher {
    matched<T extends object>(left: T, right: T): boolean | undefined;
}

/**
 * Matches Date objects
 */
declare class DateMatcher implements IObjectMatcher {
    matched<T = Date>(left: T, right: T): boolean;
}

/**
 * @hidden
 */
declare class PrimitiveMatcher {
    matched<T extends (string | number | bigint | boolean | symbol)>(left: T, right: T): boolean;
}

/**
 * @hidden
 */
declare class TypesMatcher {
    matched(left: unknown, right: unknown): boolean;
}

declare const OBJECT_MATCHERS: InjectionToken<IObjectMatcher[]>;

/**
 * @hidden
 */
declare class ObjectMatcher {
    private readonly matchers;
    constructor(matchers: TypeofInjectionToken<typeof OBJECT_MATCHERS>);
    matched<T extends Record<string, unknown>>(left: T, right: T): boolean;
}

/**
 * @hidden
 */
declare class FunctionMatcher {
    matched<T extends (...args: any[]) => unknown>(left: T, right: T): boolean;
}

/**
 * @hidden
 */
declare class EqualMatcher {
    private readonly typesMatcher;
    private readonly commonTypeProvider;
    private readonly primitiveMatcher;
    private readonly objectMatcher;
    private readonly functionMatcher;
    constructor(typesMatcher: TypesMatcher, commonTypeProvider: CommonTypeProvider, primitiveMatcher: PrimitiveMatcher, objectMatcher: ObjectMatcher, functionMatcher: FunctionMatcher);
    matched(left: any, right: any): boolean;
}

/**
 * @hidden
 */
declare class EqualConstantMatcher implements Readonly<ConstantEqualityComparer> {
    private readonly itEqualityComparer;
    private readonly equalMatcher;
    constructor(itEqualityComparer: ItEqualityComparer, equalMatcher: EqualMatcher);
    equals(left: any, right: any): boolean;
}

/**
 * @hidden
 */
declare class IterableTester {
    verify(left: unknown, right: unknown): boolean;
}

/**
 * Matches objects that support Iterable protocol
 */
declare class IteratorMatcher implements IObjectMatcher {
    private readonly injector;
    private readonly iterableTester;
    constructor(injector: Injector, iterableTester: IterableTester);
    matched<T extends object>(left: T, right: T): boolean;
}

/**
 * @hidden
 */
declare class ObjectMapProvider {
    get(object: object): Map<PropertyKey, any>;
    private getProps;
}

/**
 * Matches Map objects
 */
declare class MapMatcher implements IObjectMatcher {
    private readonly injector;
    constructor(injector: Injector);
    matched<T = Map<unknown, unknown>>(left: T, right: T): boolean;
}

/**
 * Matches objects as POJO
 */
declare class POJOMatcher implements IObjectMatcher {
    private readonly mapMatcher;
    private readonly objectMapProvider;
    constructor(mapMatcher: MapMatcher, objectMapProvider: ObjectMapProvider);
    matched<T extends object>(left: T, right: T): boolean;
}

/**
 * @Hidden
 */
declare const ROOT_MOCK: InjectionToken<IMock<unknown>>;

/**
 * @hidden
 */
declare class MockOptionsBuilder {
    build<T>(options: IMockOptions<T>): {
        name?: string;
        target: T;
        injectorConfig?: IInjectorConfig;
    };
}

/**
 * @hidden
 */
declare function mockOptionsProviders<T>(options: IMockOptions<T>): ({
    provide: typeof MockOptionsBuilder;
    useClass: typeof MockOptionsBuilder;
    deps: any[];
    useFactory?: undefined;
} | {
    provide: InjectionToken<IMockOptions<any>>;
    useFactory: (builder: any) => any;
    deps: (typeof MockOptionsBuilder)[];
    useClass?: undefined;
})[];

/**
 * @Hidden
 */
declare class MimicsRejectedAsyncPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    private readonly rejectedPromise;
    constructor(rootMock: IMock<T>, presets: Presets<T>, rejectedPromise: TypeOfInjectionFactory<RejectedPromiseFactory>);
    factory(): (target: Expressions<T>, playable: IPlayable, value: PromisedType<TValue>) => IMock<T>;
}

/**
 * @Hidden
 */
declare class MimicsResolvedAsyncPresetFactory<T, TValue = any> implements InjectionFactory {
    private readonly rootMock;
    private readonly presets;
    private readonly resolvedPromise;
    constructor(rootMock: IMock<T>, presets: Presets<T>, resolvedPromise: TypeOfInjectionFactory<ResolvedPromiseFactory>);
    factory(): (target: Expressions<T>, playable: IPlayable, value: PromisedType<TValue>) => IMock<T>;
}

declare class CallbacksPreset<T> implements IPreset<T> {
    readonly playable: IPlayable;
    readonly target: Expressions<T>;
    readonly callback: (interaction: Expression) => unknown;
    constructor(playable: IPlayable, target: Expressions<T>, callback: (interaction: Expression) => unknown);
}

declare class MimicsPreset<T> implements IPreset<T> {
    readonly playable: IPlayable;
    readonly target: Expressions<T>;
    readonly origin: unknown;
    constructor(playable: IPlayable, target: Expressions<T>, origin: unknown);
}

declare class ReturnsPreset<T, TValue> implements IPreset<T> {
    readonly playable: IPlayable;
    readonly target: Expressions<T>;
    readonly value: TValue;
    constructor(playable: IPlayable, target: Expressions<T>, value: TValue);
}

declare class ThrowsPreset<T, TException> implements IPreset<T> {
    readonly playable: IPlayable;
    readonly target: Expressions<T>;
    readonly exception: TException;
    constructor(playable: IPlayable, target: Expressions<T>, exception: TException);
}

declare class ReflectingProxyInjectorFactory {
    create(options?: {
        providers: StaticProvider[];
    }): Injector;
}

declare class AsyncReflectingProxyInjectorFactory {
    private readonly reflectingProxyInjectorFactory;
    constructor(reflectingProxyInjectorFactory: ReflectingProxyInjectorFactory);
    create(options?: {
        providers: StaticProvider[];
    }): Injector;
}

declare class MethodOnlyReflectingProxyFactory implements IReturnValueFactory {
    private readonly injector;
    constructor(injector: Injector);
    create(): any;
}

declare class MethodReflectingProxyFactory {
    private readonly injector;
    constructor(injector: Injector);
    create(): any;
}

declare class ReflectingProxyFactory implements IReturnValueFactory {
    private readonly injector;
    constructor(injector: Injector);
    create(): any;
}

declare class ApplyReflectorTrap implements InjectionFactory {
    private readonly returnValueFactory;
    private readonly expressions;
    constructor(returnValueFactory: IReturnValueFactory, expressions: Expressions<unknown>[]);
    factory(): (target: any, thisArg: any, args: any) => any;
}

declare class ConstructReflectorTrap implements InjectionFactory {
    private readonly returnValueFactory;
    private readonly expressions;
    constructor(returnValueFactory: IReturnValueFactory, expressions: Expressions<unknown>[]);
    factory(): (target: any, args: any) => any;
}

declare class GetReflectorTrap implements InjectionFactory {
    private readonly returnValueFactory;
    private readonly expressions;
    constructor(returnValueFactory: IReturnValueFactory, expressions: Expressions<unknown>[]);
    factory(): (target: any, name: any) => any;
}

declare class HasReflectorTrap implements InjectionFactory {
    private readonly expressions;
    constructor(expressions: Expressions<unknown>[]);
    factory(): (target: any, name: any) => boolean;
}

declare class MethodReflectorTrap implements InjectionFactory {
    private readonly expressions;
    constructor(expressions: Expressions<unknown>[]);
    factory(): (target: any, thisArg: any, args: any) => any;
}

declare class SetReflectorTrap implements InjectionFactory {
    private readonly expressions;
    constructor(expressions: Expressions<unknown>[]);
    factory(): (target: any, name: any, value: any) => boolean;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
declare function stringify(token: any): string;

declare class VerifyError extends Error {
    constructor(message: string);
}

export { AbstractType, ApplyReflectorTrap, ApplyTrap, ArgumentsEqualityComparer, AsyncReflectingProxyInjectorFactory, AutoMockNameFormatter, AutoMockProvider, AutoMockedStorage, CallCounter, CallbackPresetFactory, CallbackPresetPlayer, CallbacksPreset, CommonTypeProvider, ComplexExpressionErrorFormatter, ComplexExpressionGuard, ComplexExpressionValidator, ConstantEqualityComparer, ConstantFormatter, ConstructReflectorTrap, ConstructTrap, DateMatcher, EqualConstantMatcher, EqualMatcher, ExpressionEqualityComparer, ExpressionFormatter, ExpressionGuardExceptionFactory, ExpressionHasMethodExplorer, ExpressionHasPropertyExplorer, ExpressionValidator, ExpressionsFormatter, FunctionExpressionValidator, FunctionFormatter, FunctionMatcher, GetPropertyEqualityComparer, GetPropertyExpressionValidator, GetPropertyFormatter, GetPrototypeOfTrap, GetReflectorTrap, GetTrap, HasMethodExplorer, HasPropertyExplorer, HasReflectorTrap, HasTrap, IPreset, InOperatorEqualityComparer, InOperatorExpressionValidator, InOperatorFormatter, InOperatorInteractionExplorer, InjectionFactory, InstanceMethodEqualityComparer, InstanceMethodExpressionValidator, InteractionFormatter, InteractionPlayer, ItEqualityComparer, IterableTester, IteratorMatcher, MOCK_CONSTRUCTOR, MapMatcher, MembersMethodExplorer, MembersPropertyExplorer, MethodEqualityComparer, MethodFormatter, MethodOnlyReflectingProxyFactory, MethodReflectingProxyFactory, MethodReflectorTrap, MimicsPreset, MimicsPresetFactory, MimicsPresetPlayer, MimicsRejectedAsyncPresetFactory, MimicsResolvedAsyncPresetFactory, MockCore, MockOptionsBuilder, NamePrefixProvider, NewOperatorEqualityComparer, NewOperatorExpressionValidator, NewOperatorFormatter, ObjectHasMethodExplorer, ObjectHasPropertyExplorer, ObjectMapProvider, ObjectMatcher, POJOMatcher, PlayablePresetProvider, PresetBuilder, PresetBuilderFactory, PresetHasInOperatorExplorer, PresetHasMethodExplorer, PresetHasPropertyExplorer, PresetPlayablesUpdater, PresetPlayer, Presets, PrimitiveMatcher, PropertiesValueStorage, PropertyDescriptorProvider, PropertyIsReadOnlyTester, PropertyKeyFormatter, PrototypeStorage, ProxyFactory, REFLECT_APPLY, REFLECT_HAS, ROOT_MOCK, ReflectingProxyFactory, ReflectingProxyInjectorFactory, ReturnsAsyncPresetFactory, ReturnsPreset, ReturnsPresetFactory, RootMockProvider, SequenceId, SetPropertyEqualityComparer, SetPropertyExpressionValidator, SetPropertyFormatter, SetPrototypeOfTrap, SetReflectorTrap, SetTrap, SetupFactory, SpyFunctionProvider, StringErrorStyler, ThrowsAsyncPresetFactory, ThrowsPreset, ThrowsPresetFactory, TrackedExpressionsFormatter, Type, TypeOfInjectionFactory, TypesMatcher, VerificationTester, Verifier, VerifyError, VerifyFormatter, mockOptionsProviders, stringify };
